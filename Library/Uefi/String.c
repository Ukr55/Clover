///
/// @file Library/Uefi/String.c
///
/// UEFI implementation string utilities
///

#include <Uefi.h>

// CHAR_FAT_VALID
/// Bit mask to indicate the validity of character in FAT file name
#define CHAR_FAT_VALID 0x01
// MAP_TABLE_SIZE
/// Maximum FAT table size
#define MAP_TABLE_SIZE 0x100
// TO_UPPER
/// Convert character to upper case
#define TO_UPPER(a) (CHAR16)((((UINTN)a) <= 0xFF) ? mEngUpperMap[(UINTN)(a)] : (a))
// TO_LOWER
// Convert character to lower case
#define TO_LOWER(a) (CHAR16)((((UINTN)a) <= 0xFF) ? mEngLowerMap[(UINTN)(a)] : (a))
// DEFAULT_LANGUAGE
/// Default language - English
#define DEFAULT_LANGUAGE "en"

// CHARACTER_FLAG_NONE
/// The character has no modifying flags
#define CHARACTER_FLAG_NONE 0
// CHARACTER_FLAG_PRINTABLE
/// The character is considered printable or able to be represented graphically in some meaningful way
#define CHARACTER_FLAG_PRINTABLE EFI_BIT(0)

// CHARACTER_RANGE
/// A range of character values
typedef struct CHARACTER_RANGE CHARACTER_RANGE;
struct CHARACTER_RANGE {

  // Start
  /// The starting range for valid characters
  UINT32 Start;
  // End
  /// The ending range for valid characters
  UINT32 End;
  // Flags
  /// The character flags for characters in this range
  UINT32 Flags;

};

// gEfiUnicodeCollationProtocolGuid
/// The unicode collation protocol unique identifier
EFI_GUID gEfiUnicodeCollationProtocolGuid;
// gEfiUnicodeCollation2ProtocolGuid
/// The unicode collation 2 protocol unique identifier
EFI_GUID gEfiUnicodeCollation2ProtocolGuid;

// mEngUpperMap
/// Character map used for converting to upper case
STATIC CHAR8  mEngUpperMap[MAP_TABLE_SIZE];
// mEngLowerMap
/// Character map used for converting to lower case
STATIC CHAR8  mEngLowerMap[MAP_TABLE_SIZE];
// mEngInfoMap
/// Character map used for FAT conversion
STATIC CHAR8  mEngInfoMap[MAP_TABLE_SIZE];
// mOtherChars
/// Other characters valid for FAT
STATIC CHAR8  mOtherChars[] = {
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  '\\',
  '.',
  '_',
  '^',
  '$',
  '~',
  '!',
  '#',
  '%',
  '&',
  '-',
  '{',
  '}',
  '(',
  ')',
  '@',
  '`',
  '\'',
  '\0'
};

// mValidCharRanges
/// The valid character ranges for unicode 10.0
STATIC CHARACTER_RANGE mValidCharRanges[] = {
  // Control C0
  { 0x00000000, 0x0000001F, CHARACTER_FLAG_NONE },
  // Basic Latin
  { 0x00000020, 0x0000007E, CHARACTER_FLAG_PRINTABLE },
  // Control C1
  { 0x0000007F, 0x0000009F, CHARACTER_FLAG_NONE },
  // Latin-1, Extended Latin-A, Extended Latin-B, IPA Extensions, Spacing Modifier Letters, Combining Diacritical marks
  { 0x000000A0, 0x00000377, CHARACTER_FLAG_PRINTABLE },
  // Greek, Coptic, Cyrillic
  { 0x0000037A, 0x0000037F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000384, 0x0000038A, CHARACTER_FLAG_PRINTABLE },
  { 0x0000038C, 0x0000038C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000038E, 0x000003A1, CHARACTER_FLAG_PRINTABLE },
  { 0x000003A3, 0x0000052F, CHARACTER_FLAG_PRINTABLE },
  // Armenian
  { 0x00000531, 0x00000556, CHARACTER_FLAG_PRINTABLE },
  { 0x00000559, 0x0000055F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000561, 0x00000587, CHARACTER_FLAG_PRINTABLE },
  { 0x00000589, 0x0000058A, CHARACTER_FLAG_PRINTABLE },
  { 0x0000058D, 0x0000058F, CHARACTER_FLAG_PRINTABLE },
  // Hebrew
  { 0x00000591, 0x000005C7, CHARACTER_FLAG_PRINTABLE },
  { 0x000005D0, 0x000005EA, CHARACTER_FLAG_PRINTABLE },
  { 0x000005F0, 0x000005F4, CHARACTER_FLAG_PRINTABLE },
  // Arabic
  { 0x00000600, 0x0000061C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000061E, 0x0000070D, CHARACTER_FLAG_PRINTABLE },
  // Syriac
  { 0x0000070F, 0x0000074A, CHARACTER_FLAG_PRINTABLE },
  // Arabic supplement, Thaana
  { 0x0000074D, 0x000007B1, CHARACTER_FLAG_PRINTABLE },
  // NKo
  { 0x000007C0, 0x000007FA, CHARACTER_FLAG_PRINTABLE },
  // Samaritan
  { 0x00000800, 0x0000082D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000830, 0x0000083E, CHARACTER_FLAG_PRINTABLE },
  // Mandaic
  { 0x00000840, 0x0000085B, CHARACTER_FLAG_PRINTABLE },
  { 0x0000085E, 0x0000085E, CHARACTER_FLAG_PRINTABLE },
  // Arabic Extended-A
  { 0x000008A0, 0x000008B4, CHARACTER_FLAG_PRINTABLE },
  { 0x000008B6, 0x000008BD, CHARACTER_FLAG_PRINTABLE },
  // Devanagari
  { 0x000008D4, 0x00000983, CHARACTER_FLAG_PRINTABLE },
  // Bengali
  { 0x00000985, 0x0000098C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000098F, 0x00000990, CHARACTER_FLAG_PRINTABLE },
  { 0x00000993, 0x000009A8, CHARACTER_FLAG_PRINTABLE },
  { 0x000009AA, 0x000009B0, CHARACTER_FLAG_PRINTABLE },
  { 0x000009B2, 0x000009B2, CHARACTER_FLAG_PRINTABLE },
  { 0x000009B6, 0x000009B9, CHARACTER_FLAG_PRINTABLE },
  { 0x000009BC, 0x000009C4, CHARACTER_FLAG_PRINTABLE },
  { 0x000009C7, 0x000009C8, CHARACTER_FLAG_PRINTABLE },
  { 0x000009CB, 0x000009CE, CHARACTER_FLAG_PRINTABLE },
  { 0x000009D7, 0x000009D7, CHARACTER_FLAG_PRINTABLE },
  { 0x0000070F, 0x0000074A, CHARACTER_FLAG_PRINTABLE },
  { 0x000009DC, 0x000009DD, CHARACTER_FLAG_PRINTABLE },
  { 0x000009DF, 0x000009E3, CHARACTER_FLAG_PRINTABLE },
  { 0x000009E6, 0x000009FB, CHARACTER_FLAG_PRINTABLE },
  // Gurmukhi
  { 0x00000A01, 0x00000A03, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A05, 0x00000A0A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A0F, 0x00000A10, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A13, 0x00000A28, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A2A, 0x00000A30, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A32, 0x00000A33, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A35, 0x00000A36, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A38, 0x00000A39, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A3C, 0x00000A3C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A3E, 0x00000A42, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A47, 0x00000A48, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A4B, 0x00000A4D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A51, 0x00000A51, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A59, 0x00000A5C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A5E, 0x00000A5E, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A66, 0x00000A75, CHARACTER_FLAG_PRINTABLE },
  // Gujarati
  { 0x00000A81, 0x00000A83, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A85, 0x00000A8D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A8F, 0x00000A91, CHARACTER_FLAG_PRINTABLE },
  { 0x00000A93, 0x00000AA8, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AAA, 0x00000AB0, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AB2, 0x00000AB3, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AB5, 0x00000AB9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000ABC, 0x00000AC5, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AC7, 0x00000AC9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000ACB, 0x00000ACD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AD0, 0x00000AD0, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AE0, 0x00000AE3, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AE6, 0x00000AF1, CHARACTER_FLAG_PRINTABLE },
  { 0x00000AF9, 0x00000AF9, CHARACTER_FLAG_PRINTABLE },
  // Oriya
  { 0x00000B01, 0x00000B03, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B05, 0x00000B0C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B0F, 0x00000B10, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B13, 0x00000B28, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B2A, 0x00000B30, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B32, 0x00000B33, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B35, 0x00000B39, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B3C, 0x00000B44, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B47, 0x00000B48, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B4B, 0x00000B4D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B56, 0x00000B57, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B5C, 0x00000B5D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B5F, 0x00000B63, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B66, 0x00000B77, CHARACTER_FLAG_PRINTABLE },
  // Tamil
  { 0x00000B82, 0x00000B83, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B85, 0x00000B8A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B8E, 0x00000B90, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B92, 0x00000B95, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B99, 0x00000B9A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B9C, 0x00000B9C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000B9E, 0x00000B9F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BA3, 0x00000BA4, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BA9, 0x00000BAA, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BAE, 0x00000BB9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BBE, 0x00000BC2, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BC6, 0x00000BC8, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BCA, 0x00000BCD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BD0, 0x00000BD0, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BD7, 0x00000BD7, CHARACTER_FLAG_PRINTABLE },
  { 0x00000BE6, 0x00000BFA, CHARACTER_FLAG_PRINTABLE },
  // Telugu
  { 0x00000C00, 0x00000C03, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C05, 0x00000C0C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C0E, 0x00000C10, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C12, 0x00000C28, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C2A, 0x00000C39, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C3D, 0x00000C44, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C46, 0x00000C48, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C4A, 0x00000C4D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C55, 0x00000C56, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C58, 0x00000C5A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C60, 0x00000C63, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C66, 0x00000C6F, CHARACTER_FLAG_PRINTABLE },
  // Kannada
  { 0x00000C78, 0x00000C7F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C80, 0x00000C83, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C85, 0x00000C8C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C8E, 0x00000C90, CHARACTER_FLAG_PRINTABLE },
  { 0x00000C92, 0x00000CA8, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CAA, 0x00000CB3, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CB5, 0x00000CB9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CBC, 0x00000CC4, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CC6, 0x00000CC8, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CCA, 0x00000CCD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CD5, 0x00000CD6, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CDE, 0x00000CDE, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CE0, 0x00000CE3, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CE6, 0x00000CEF, CHARACTER_FLAG_PRINTABLE },
  { 0x00000CF1, 0x00000CF2, CHARACTER_FLAG_PRINTABLE },
  // Malayalam
  { 0x00000D01, 0x00000D03, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D05, 0x00000D0C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D0E, 0x00000D10, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D12, 0x00000D3A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D3D, 0x00000D4D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D01, 0x00000D03, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D46, 0x00000D48, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D4A, 0x00000D4F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D54, 0x00000D63, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D66, 0x00000D7F, CHARACTER_FLAG_PRINTABLE },
  // Sinhala
  { 0x00000D82, 0x00000D83, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D85, 0x00000D96, CHARACTER_FLAG_PRINTABLE },
  { 0x00000D9A, 0x00000DB1, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DB3, 0x00000DBB, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DBD, 0x00000DBD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DC0, 0x00000DC6, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DCA, 0x00000DCA, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DCF, 0x00000DD4, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DD6, 0x00000DD6, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DD8, 0x00000DDF, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DE6, 0x00000DEF, CHARACTER_FLAG_PRINTABLE },
  { 0x00000DF2, 0x00000DF4, CHARACTER_FLAG_PRINTABLE },
  // Thai
  { 0x00000E01, 0x00000E3A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E3F, 0x00000E5B, CHARACTER_FLAG_PRINTABLE },
  // Lao
  { 0x00000E81, 0x00000E82, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E84, 0x00000E84, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E87, 0x00000E88, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E8A, 0x00000E8A, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E8D, 0x00000E8D, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E94, 0x00000E97, CHARACTER_FLAG_PRINTABLE },
  { 0x00000E99, 0x00000E9F, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EA1, 0x00000EA3, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EA5, 0x00000EA5, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EA7, 0x00000EA7, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EAA, 0x00000EAB, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EAD, 0x00000EB9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EBB, 0x00000EBD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EC0, 0x00000EC4, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EC6, 0x00000EC6, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EC8, 0x00000ECD, CHARACTER_FLAG_PRINTABLE },
  { 0x00000ED0, 0x00000ED9, CHARACTER_FLAG_PRINTABLE },
  { 0x00000EDC, 0x00000EDF, CHARACTER_FLAG_PRINTABLE },
  // Tibetan
  { 0x00000F00, 0x00000F47, CHARACTER_FLAG_PRINTABLE },
  { 0x00000F49, 0x00000F6C, CHARACTER_FLAG_PRINTABLE },
  { 0x00000F71, 0x00000F97, CHARACTER_FLAG_PRINTABLE },
  { 0x00000F99, 0x00000FBC, CHARACTER_FLAG_PRINTABLE },
  { 0x00000FBE, 0x00000FCC, CHARACTER_FLAG_PRINTABLE },
  { 0x00000FCE, 0x00000FDA, CHARACTER_FLAG_PRINTABLE },
  // Myanmar, Georgian
  { 0x00001000, 0x000010C5, CHARACTER_FLAG_PRINTABLE },
  { 0x000010C7, 0x000010C7, CHARACTER_FLAG_PRINTABLE },
  { 0x000010CD, 0x000010CD, CHARACTER_FLAG_PRINTABLE },
  // Georgian, Hangul Jamo, Ethiopic
  { 0x000010D0, 0x00001248, CHARACTER_FLAG_PRINTABLE },
  // Ethiopic
  { 0x0000124A, 0x0000124D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001250, 0x00001256, CHARACTER_FLAG_PRINTABLE },
  { 0x00001258, 0x00001258, CHARACTER_FLAG_PRINTABLE },
  { 0x0000125A, 0x0000125D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001260, 0x00001288, CHARACTER_FLAG_PRINTABLE },
  { 0x0000128A, 0x0000128D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001290, 0x000012B0, CHARACTER_FLAG_PRINTABLE },
  { 0x000012B2, 0x000012B5, CHARACTER_FLAG_PRINTABLE },
  { 0x000012B8, 0x000012BE, CHARACTER_FLAG_PRINTABLE },
  { 0x000012C0, 0x000012C0, CHARACTER_FLAG_PRINTABLE },
  { 0x000012C2, 0x000012C5, CHARACTER_FLAG_PRINTABLE },
  { 0x000012C8, 0x000012D6, CHARACTER_FLAG_PRINTABLE },
  { 0x000012D8, 0x00001310, CHARACTER_FLAG_PRINTABLE },
  { 0x00001312, 0x00001315, CHARACTER_FLAG_PRINTABLE },
  { 0x00001318, 0x0000135A, CHARACTER_FLAG_PRINTABLE },
  { 0x0000135D, 0x0000137C, CHARACTER_FLAG_PRINTABLE },
  // Ethiopic Supplement
  { 0x00001380, 0x00001399, CHARACTER_FLAG_PRINTABLE },
  // Cherokee
  { 0x000013A0, 0x000013F5, CHARACTER_FLAG_PRINTABLE },
  { 0x000013F8, 0x000013FD, CHARACTER_FLAG_PRINTABLE },
  // Unified Canadian Aboriginal Syllabics, Ogham
  { 0x00001400, 0x0000169C, CHARACTER_FLAG_PRINTABLE },
  // Runic
  { 0x000016A0, 0x000016F8, CHARACTER_FLAG_PRINTABLE },
  // Tagalog
  { 0x00001700, 0x0000170C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000170E, 0x00001714, CHARACTER_FLAG_PRINTABLE },
  // Hanunoo
  { 0x00001720, 0x00001736, CHARACTER_FLAG_PRINTABLE },
  // Buhid
  { 0x00001740, 0x00001753, CHARACTER_FLAG_PRINTABLE },
  // Tagbanwa
  { 0x00001760, 0x0000176C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000176E, 0x00001770, CHARACTER_FLAG_PRINTABLE },
  { 0x00001772, 0x00001773, CHARACTER_FLAG_PRINTABLE },
  // Khmer
  { 0x00001780, 0x000017DD, CHARACTER_FLAG_PRINTABLE },
  { 0x000017E0, 0x000017E9, CHARACTER_FLAG_PRINTABLE },
  { 0x000017F0, 0x000017F9, CHARACTER_FLAG_PRINTABLE },
  // Mongolian
  { 0x00001800, 0x0000180E, CHARACTER_FLAG_PRINTABLE },
  { 0x00001810, 0x00001819, CHARACTER_FLAG_PRINTABLE },
  { 0x00001820, 0x00001877, CHARACTER_FLAG_PRINTABLE },
  { 0x00001880, 0x000018AA, CHARACTER_FLAG_PRINTABLE },
  // Unified Canadian Aboriginal Syllabics Extended
  { 0x000018B0, 0x000018F5, CHARACTER_FLAG_PRINTABLE },
  // Limbu
  { 0x00001900, 0x0000191E, CHARACTER_FLAG_PRINTABLE },
  { 0x00001920, 0x0000192B, CHARACTER_FLAG_PRINTABLE },
  { 0x00001930, 0x0000193B, CHARACTER_FLAG_PRINTABLE },
  { 0x00001940, 0x00001940, CHARACTER_FLAG_PRINTABLE },
  { 0x00001944, 0x0000194F, CHARACTER_FLAG_PRINTABLE },
  // Tai Le
  { 0x00001950, 0x0000196D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001970, 0x00001974, CHARACTER_FLAG_PRINTABLE },
  // New Tai Lue
  { 0x00001980, 0x000019AB, CHARACTER_FLAG_PRINTABLE },
  { 0x000019B0, 0x000019C9, CHARACTER_FLAG_PRINTABLE },
  { 0x000019D0, 0x000019DA, CHARACTER_FLAG_PRINTABLE },
  // Khmer Symbols, Buginese
  { 0x000019DE, 0x00001A1B, CHARACTER_FLAG_PRINTABLE },
  // Tai Tham
  { 0x00001A1E, 0x00001A5E, CHARACTER_FLAG_PRINTABLE },
  { 0x00001A60, 0x00001A7C, CHARACTER_FLAG_PRINTABLE },
  { 0x00001A7F, 0x00001A89, CHARACTER_FLAG_PRINTABLE },
  { 0x00001A90, 0x00001A99, CHARACTER_FLAG_PRINTABLE },
  { 0x00001AA0, 0x00001AAD, CHARACTER_FLAG_PRINTABLE },
  // Combining Diacritical Marks Extended
  { 0x00001AB0, 0x00001ABE, CHARACTER_FLAG_PRINTABLE },
  // Balinese
  { 0x00001B00, 0x00001B4B, CHARACTER_FLAG_PRINTABLE },
  { 0x00001B50, 0x00001B7C, CHARACTER_FLAG_PRINTABLE },
  // Sundanese, Batak
  { 0x00001B80, 0x00001BF3, CHARACTER_FLAG_PRINTABLE },
  // Lepcha
  { 0x00001BFC, 0x00001C37, CHARACTER_FLAG_PRINTABLE },
  { 0x00001C3B, 0x00001C49, CHARACTER_FLAG_PRINTABLE },
  // Ol Chiki, Cyrillic Extended-C
  { 0x00001C4D, 0x00001C88, CHARACTER_FLAG_PRINTABLE },
  // Sundanese Supplement
  { 0x00001CC0, 0x00001CC7, CHARACTER_FLAG_PRINTABLE },
  // Vedic Extensions
  { 0x00001CD0, 0x00001CF6, CHARACTER_FLAG_PRINTABLE },
  { 0x00001CF8, 0x00001CF9, CHARACTER_FLAG_PRINTABLE },
  // Phonetic Extensions, Phonetic Extensions Supplement, Combining Diacritical Marks Supplement
  { 0x00001D00, 0x00001DF5, CHARACTER_FLAG_PRINTABLE },
  // Latin Extended Additional, Greek Extended
  { 0x00001DFB, 0x00001F15, CHARACTER_FLAG_PRINTABLE },
  // Greek Extended
  { 0x00001F18, 0x00001F1D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F20, 0x00001F45, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F48, 0x00001F4D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F50, 0x00001F57, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F59, 0x00001F59, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F5B, 0x00001F5B, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F5D, 0x00001F5D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F5F, 0x00001F7D, CHARACTER_FLAG_PRINTABLE },
  { 0x00001F80, 0x00001FB4, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FB6, 0x00001FC4, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FC6, 0x00001FD3, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FD6, 0x00001FDB, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FDD, 0x00001FEF, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FF2, 0x00001FF4, CHARACTER_FLAG_PRINTABLE },
  { 0x00001FF6, 0x00001FFE, CHARACTER_FLAG_PRINTABLE },
  // General Punctuation
  { 0x00002000, 0x00002064, CHARACTER_FLAG_PRINTABLE },
  { 0x00002066, 0x00002071, CHARACTER_FLAG_PRINTABLE },
  // Superscripts and Subscripts
  { 0x00002074, 0x0000208E, CHARACTER_FLAG_PRINTABLE },
  { 0x00002090, 0x0000209C, CHARACTER_FLAG_PRINTABLE },
  // Currency Symbols
  { 0x000020A0, 0x000020BE, CHARACTER_FLAG_PRINTABLE },
  // Combining Diacritical Marks for Symbols
  { 0x000020D0, 0x000020F1, CHARACTER_FLAG_PRINTABLE },
  // Letterlike Symbols, Number Forms
  { 0x00002100, 0x0000218B, CHARACTER_FLAG_PRINTABLE },
  // Arrows, Mathematical Operators, Miscellaneous Technical
  { 0x00002190, 0x000023FE, CHARACTER_FLAG_PRINTABLE },
  // Control Pictures
  { 0x00002400, 0x00002426, CHARACTER_FLAG_PRINTABLE },
  // Optical Character Recognition
  { 0x00002440, 0x0000244A, CHARACTER_FLAG_PRINTABLE },
  // Enclosed Alphanumerics, Box Drawing, Box Elements, Geometric Shapes, Miscellaneous Symbols, Dingbats,
  // Miscellaneous Mathematical Symbols-A, Supplemental Arrows-A, Braille Patterns, Supplemental Arrows-B,
  // Miscellaneous Mathematical Symbols-B, Supplemental Mathematical Operators, Miscellaneous Symbols and Arrows
  { 0x00002460, 0x00002B73, CHARACTER_FLAG_PRINTABLE },
  // Miscellaneous Symbols and Arrows
  { 0x00002B76, 0x00002B95, CHARACTER_FLAG_PRINTABLE },
  { 0x00002B98, 0x00002BB9, CHARACTER_FLAG_PRINTABLE },
  { 0x00002BBD, 0x00002BC8, CHARACTER_FLAG_PRINTABLE },
  { 0x00002BCA, 0x00002BD1, CHARACTER_FLAG_PRINTABLE },
  { 0x00002BEC, 0x00002BEF, CHARACTER_FLAG_PRINTABLE },
  // Glagolitic
  { 0x00002C00, 0x00002C2E, CHARACTER_FLAG_PRINTABLE },
  { 0x00002C30, 0x00002C5E, CHARACTER_FLAG_PRINTABLE },
  // Latin Extended-C, Coptic
  { 0x00002C60, 0x00002CF3, CHARACTER_FLAG_PRINTABLE },
  // Georgian Supplement
  { 0x00002CF9, 0x00002D25, CHARACTER_FLAG_PRINTABLE },
  { 0x00002D27, 0x00002D27, CHARACTER_FLAG_PRINTABLE },
  { 0x00002D2D, 0x00002D2D, CHARACTER_FLAG_PRINTABLE },
  // Tifinagh
  { 0x00002D30, 0x00002D67, CHARACTER_FLAG_PRINTABLE },
  { 0x00002D6F, 0x00002D70, CHARACTER_FLAG_PRINTABLE },
  // Ethiopic Extended
  { 0x00002D7F, 0x00002D96, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DA0, 0x00002DA6, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DA8, 0x00002DAE, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DB0, 0x00002DB6, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DB8, 0x00002DBE, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DC0, 0x00002DC6, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DC8, 0x00002DCE, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DD0, 0x00002DE6, CHARACTER_FLAG_PRINTABLE },
  { 0x00002DD8, 0x00002DDE, CHARACTER_FLAG_PRINTABLE },
  // Cyrillic Extended-A, Supplemental Punctuation
  { 0x00002DE0, 0x00002E44, CHARACTER_FLAG_PRINTABLE },
  // CJK Radicals Supplement
  { 0x00002E80, 0x00002E99, CHARACTER_FLAG_PRINTABLE },
  { 0x00002E9B, 0x00002EF3, CHARACTER_FLAG_PRINTABLE },
  // Kangxi Radicals
  { 0x00002F00, 0x00002FD5, CHARACTER_FLAG_PRINTABLE },
  // Ideographic Description Characters
  { 0x00002FF0, 0x00002FFB, CHARACTER_FLAG_PRINTABLE },
  // CJK Symbols and Punctuation
  { 0x00003000, 0x0000303F, CHARACTER_FLAG_PRINTABLE },
  // Hiragana, Katakana
  { 0x00003041, 0x00003096, CHARACTER_FLAG_PRINTABLE },
  { 0x00003099, 0x000030FF, CHARACTER_FLAG_PRINTABLE },
  // Bopomofo
  { 0x00003105, 0x0000312D, CHARACTER_FLAG_PRINTABLE },
  // Hangul Compatibility Jamo
  { 0x00003131, 0x0000318E, CHARACTER_FLAG_PRINTABLE },
  // Kanbun, Bopomofo Extended
  { 0x00003190, 0x000031BA, CHARACTER_FLAG_PRINTABLE },
  // CJK Strokes
  { 0x000031F0, 0x0000321E, CHARACTER_FLAG_PRINTABLE },
  // Katakana Phonetic Extensions, Enclosed CJK Letters and Months
  { 0x000031F0, 0x0000321E, CHARACTER_FLAG_PRINTABLE },
  { 0x00003220, 0x000032FE, CHARACTER_FLAG_PRINTABLE },
  // CJK Compatibility
  { 0x00003300, 0x000033FF, CHARACTER_FLAG_PRINTABLE },
  // CJK Unified Ideographs Extension A
  { 0x00003400, 0x00004DB5, CHARACTER_FLAG_PRINTABLE },
  // Yijing Hexagram Symbols, CJK Unified Ideographs
  { 0x00004DC0, 0x00009FD5, CHARACTER_FLAG_PRINTABLE },
  // Yi Syllables
  { 0x0000A000, 0x0000A48C, CHARACTER_FLAG_PRINTABLE },
  // Yi Radicals
  { 0x0000A490, 0x0000A4C6, CHARACTER_FLAG_PRINTABLE },
  // Lisu
  { 0x0000A4D0, 0x0000A4FF, CHARACTER_FLAG_PRINTABLE },
  // Vai
  { 0x0000A500, 0x0000A62B, CHARACTER_FLAG_PRINTABLE },
  // Cyrillic Extended-B, Bamum
  { 0x0000A640, 0x0000A6F7, CHARACTER_FLAG_PRINTABLE },
  // Modifier Tone Letters, Latin Extended-D
  { 0x0000A700, 0x0000A7B7, CHARACTER_FLAG_PRINTABLE },
  // Syloti Nagri
  { 0x0000A7F7, 0x0000A82B, CHARACTER_FLAG_PRINTABLE },
  // Common Indic Number Forms
  { 0x0000A830, 0x0000A389, CHARACTER_FLAG_PRINTABLE },
  // Phags-pa
  { 0x0000A840, 0x0000A877, CHARACTER_FLAG_PRINTABLE },
  // Saurashtra
  { 0x0000A880, 0x0000A8C5, CHARACTER_FLAG_PRINTABLE },
  { 0x0000A8CE, 0x0000A8D9, CHARACTER_FLAG_PRINTABLE },
  // Devanagari Extended
  { 0x0000A8E0, 0x0000A8FD, CHARACTER_FLAG_PRINTABLE },
  // Kayah Li, Rejang
  { 0x0000A900, 0x0000A953, CHARACTER_FLAG_PRINTABLE },
  // Hangul Jamo Extended-A
  { 0x0000A95F, 0x0000A97C, CHARACTER_FLAG_PRINTABLE },
  // Javanese
  { 0x0000A980, 0x0000A9CD, CHARACTER_FLAG_PRINTABLE },
  { 0x0000A9CF, 0x0000A9D9, CHARACTER_FLAG_PRINTABLE },
  // Myanmar Extended-B
  { 0x0000A9DE, 0x0000A9FE, CHARACTER_FLAG_PRINTABLE },
  // Cham
  { 0x0000AA00, 0x0000AA36, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AA40, 0x0000AA4D, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AA50, 0x0000AA59, CHARACTER_FLAG_PRINTABLE },
  // Myanmar Extended-A, Tai Viet
  { 0x0000AA5C, 0x0000AAC2, CHARACTER_FLAG_PRINTABLE },
  // Meetei Mayek Extensions
  { 0x0000AADB, 0x0000AAF6, CHARACTER_FLAG_PRINTABLE },
  // Ethiopic Extended-A
  { 0x0000AB01, 0x0000AB06, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AB09, 0x0000AB0E, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AB11, 0x0000AB16, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AB20, 0x0000AB26, CHARACTER_FLAG_PRINTABLE },
  { 0x0000AB28, 0x0000AB2E, CHARACTER_FLAG_PRINTABLE },
  // Latin Extended-E
  { 0x0000AB30, 0x0000AB65, CHARACTER_FLAG_PRINTABLE },
  // Cherokee Supplement, Meetei Mayek
  { 0x0000AB70, 0x0000ABED, CHARACTER_FLAG_PRINTABLE },
  { 0x0000ABF0, 0x0000ABF9, CHARACTER_FLAG_PRINTABLE },
  // Hangul Syllables
  { 0x0000AC00, 0x0000D7A3, CHARACTER_FLAG_PRINTABLE },
  // Hangul Jamo Extended-B
  { 0x0000D7B0, 0x0000D7C6, CHARACTER_FLAG_PRINTABLE },
  { 0x0000D7CB, 0x0000D7FB, CHARACTER_FLAG_PRINTABLE },
  // Surrogate pairs - not valid characters
  // { 0x0000D800, 0x0000DFFF, CHARACTER_FLAG_NONE },
  // CJK Compatibility Ideographs
  { 0x0000F900, 0x0000FA6D, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FA70, 0x0000FAD9, CHARACTER_FLAG_PRINTABLE },
  // Alphabetic Presentation Forms
  { 0x0000FB00, 0x0000FB06, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB13, 0x0000FB17, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB1D, 0x0000FB36, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB38, 0x0000FB3C, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB3E, 0x0000FB3E, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB40, 0x0000FB41, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FB43, 0x0000FB44, CHARACTER_FLAG_PRINTABLE },
  // Arabic Presentation Forms-A
  { 0x0000FB46, 0x0000FBC1, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FBD3, 0x0000FD3F, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FD50, 0x0000FD8F, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FD92, 0x0000FDC7, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FDF0, 0x0000FDFD, CHARACTER_FLAG_PRINTABLE },
  // Variation Selectors, Vertical Forms
  { 0x0000FE00, 0x0000FE19, CHARACTER_FLAG_PRINTABLE },
  // Combining Half Marks, CJK Compatibility Forms
  { 0x0000FE20, 0x0000FE52, CHARACTER_FLAG_PRINTABLE },
  // Small Form Variants
  { 0x0000FE54, 0x0000FE66, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FE68, 0x0000FE6B, CHARACTER_FLAG_PRINTABLE },
  // Arabic Presentation Forms-B
  { 0x0000FE70, 0x0000FE74, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FE76, 0x0000FEFC, CHARACTER_FLAG_PRINTABLE },
  // Byte order mark
  { 0x0000FEFF, 0x0000FEFF, CHARACTER_FLAG_NONE },
  // Halfwidth and Fullwidth Forms
  { 0x0000FF01, 0x0000FFBE, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFC2, 0x0000FFC7, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFCA, 0x0000FFCF, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFD2, 0x0000FFD7, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFDA, 0x0000FFDC, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFE0, 0x0000FFE6, CHARACTER_FLAG_PRINTABLE },
  { 0x0000FFE8, 0x0000FFEE, CHARACTER_FLAG_PRINTABLE },
  // Specials
  { 0x0000FFF9, 0x0000FFFD, CHARACTER_FLAG_PRINTABLE },
  // Linear B Syllabary
  { 0x00010000, 0x0001000B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001000D, 0x00010026, CHARACTER_FLAG_PRINTABLE },
  { 0x00010028, 0x0001003A, CHARACTER_FLAG_PRINTABLE },
  { 0x0001003C, 0x0001003D, CHARACTER_FLAG_PRINTABLE },
  { 0x0001003F, 0x0001004D, CHARACTER_FLAG_PRINTABLE },
  { 0x00010050, 0x0001005D, CHARACTER_FLAG_PRINTABLE },
  // Linear B Ideograms
  { 0x00010080, 0x000100FA, CHARACTER_FLAG_PRINTABLE },
  // Aegean Numbers
  { 0x00010100, 0x00010102, CHARACTER_FLAG_PRINTABLE },
  { 0x00010107, 0x00010133, CHARACTER_FLAG_PRINTABLE },
  // Ancient Greek Numbers
  { 0x00010137, 0x0001018E, CHARACTER_FLAG_PRINTABLE },
  // Ancient Symbols
  { 0x00010190, 0x0001019B, CHARACTER_FLAG_PRINTABLE },
  { 0x000101A0, 0x000101A0, CHARACTER_FLAG_PRINTABLE },
  // Phaistos Disc
  { 0x000101D0, 0x000101FD, CHARACTER_FLAG_PRINTABLE },
  // Lycian
  { 0x00010280, 0x0001029C, CHARACTER_FLAG_PRINTABLE },
  // Carian
  { 0x000102A0, 0x000102D0, CHARACTER_FLAG_PRINTABLE },
  // Coptic Epact Numbers
  { 0x000102E0, 0x000102FB, CHARACTER_FLAG_PRINTABLE },
  // Old Italic
  { 0x00010300, 0x00010323, CHARACTER_FLAG_PRINTABLE },
  // Gothic
  { 0x00010330, 0x0001034A, CHARACTER_FLAG_PRINTABLE },
  // Old Permic
  { 0x00010350, 0x0001037A, CHARACTER_FLAG_PRINTABLE },
  // Ugaritic
  { 0x00010380, 0x0001039D, CHARACTER_FLAG_PRINTABLE },
  // Old Persian
  { 0x0001039F, 0x000103C3, CHARACTER_FLAG_PRINTABLE },
  { 0x000103C8, 0x000103D5, CHARACTER_FLAG_PRINTABLE },
  // Deseret, Shavian, Osmanya
  { 0x00010400, 0x0001049D, CHARACTER_FLAG_PRINTABLE },
  { 0x000104A0, 0x000104A9, CHARACTER_FLAG_PRINTABLE },
  // Osage
  { 0x000102B0, 0x000104D3, CHARACTER_FLAG_PRINTABLE },
  { 0x000104D8, 0x000104FB, CHARACTER_FLAG_PRINTABLE },
  // Elbasan
  { 0x00010500, 0x00010527, CHARACTER_FLAG_PRINTABLE },
  // Caucasian Albanian
  { 0x00010530, 0x00010563, CHARACTER_FLAG_PRINTABLE },
  { 0x0001056F, 0x0001056F, CHARACTER_FLAG_PRINTABLE },
  // Linear A
  { 0x00010600, 0x00010736, CHARACTER_FLAG_PRINTABLE },
  { 0x00010740, 0x00010755, CHARACTER_FLAG_PRINTABLE },
  { 0x00010760, 0x00010767, CHARACTER_FLAG_PRINTABLE },
  // Cypriot Syllabary
  { 0x00010800, 0x00010805, CHARACTER_FLAG_PRINTABLE },
  { 0x00010808, 0x00010808, CHARACTER_FLAG_PRINTABLE },
  { 0x0001080A, 0x00010835, CHARACTER_FLAG_PRINTABLE },
  { 0x00010837, 0x00010838, CHARACTER_FLAG_PRINTABLE },
  { 0x0001083C, 0x0001083C, CHARACTER_FLAG_PRINTABLE },
  // Imperial Aramaic, Palmyrene, Nabataean
  { 0x0001083F, 0x00010855, CHARACTER_FLAG_PRINTABLE },
  { 0x00010857, 0x0001089E, CHARACTER_FLAG_PRINTABLE },
  { 0x000108A7, 0x000108AF, CHARACTER_FLAG_PRINTABLE },
  // Hatran
  { 0x000108E0, 0x000108F2, CHARACTER_FLAG_PRINTABLE },
  { 0x000108F4, 0x000108F5, CHARACTER_FLAG_PRINTABLE },
  // Phoenician
  { 0x000108FB, 0x0001091B, CHARACTER_FLAG_PRINTABLE },
  // Lydian
  { 0x0001091F, 0x00010939, CHARACTER_FLAG_PRINTABLE },
  { 0x0001093F, 0x0001093F, CHARACTER_FLAG_PRINTABLE },
  // Meroitic Hieroglyphs
  { 0x00010980, 0x000109B7, CHARACTER_FLAG_PRINTABLE },
  // Meroitic Cursive
  { 0x000109BC, 0x000109CF, CHARACTER_FLAG_PRINTABLE },
  { 0x000109D2, 0x00010A03, CHARACTER_FLAG_PRINTABLE },
  // Kharoshthi
  { 0x00010A05, 0x00010A06, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A0C, 0x00010A13, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A15, 0x00010A17, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A19, 0x00010A33, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A38, 0x00010A3A, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A3F, 0x00010A47, CHARACTER_FLAG_PRINTABLE },
  { 0x00010A50, 0x00010A58, CHARACTER_FLAG_PRINTABLE },
  // Old South Arabian, Old North Arabian
  { 0x00010A60, 0x00010A9F, CHARACTER_FLAG_PRINTABLE },
  // Manichaean
  { 0x00010AC0, 0x00010AE6, CHARACTER_FLAG_PRINTABLE },
  { 0x00010AEB, 0x00010AF6, CHARACTER_FLAG_PRINTABLE },
  // Avestan
  { 0x00010B00, 0x00010B35, CHARACTER_FLAG_PRINTABLE },
  // Inscriptional Parthian
  { 0x00010B39, 0x00010B55, CHARACTER_FLAG_PRINTABLE },
  // Inscriptional Pahlavi
  { 0x00010B58, 0x00010B72, CHARACTER_FLAG_PRINTABLE },
  // Psalter Pahlavi
  { 0x00010B60, 0x00010B7E, CHARACTER_FLAG_PRINTABLE },
  { 0x00010B60, 0x00010B7E, CHARACTER_FLAG_PRINTABLE },
  { 0x00010B60, 0x00010B7E, CHARACTER_FLAG_PRINTABLE },
  // Old Turkic
  { 0x00010C00, 0x00010C48, CHARACTER_FLAG_PRINTABLE },
  // Old Hungarian
  { 0x00010C80, 0x00010CB2, CHARACTER_FLAG_PRINTABLE },
  { 0x00010CC0, 0x00010CF2, CHARACTER_FLAG_PRINTABLE },
  { 0x00010CFA, 0x00010CFF, CHARACTER_FLAG_PRINTABLE },
  // Rumi Numeral Symbols
  { 0x00010E60, 0x00010E7E, CHARACTER_FLAG_PRINTABLE },
  // Brahmi
  { 0x00011000, 0x0001104D, CHARACTER_FLAG_PRINTABLE },
  { 0x00011052, 0x0001106F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001107F, 0x0001107F, CHARACTER_FLAG_PRINTABLE },
  // Kaithi
  { 0x00011080, 0x000110C1, CHARACTER_FLAG_PRINTABLE },
  // Sora Sompeng
  { 0x000110D0, 0x000110E8, CHARACTER_FLAG_PRINTABLE },
  { 0x000110F0, 0x000110F9, CHARACTER_FLAG_PRINTABLE },
  // Chakma
  { 0x00011100, 0x00011134, CHARACTER_FLAG_PRINTABLE },
  { 0x00011136, 0x00011143, CHARACTER_FLAG_PRINTABLE },
  // Mahajani
  { 0x00011150, 0x00011176, CHARACTER_FLAG_PRINTABLE },
  // Sharada
  { 0x00011180, 0x000111CD, CHARACTER_FLAG_PRINTABLE },
  { 0x000111D0, 0x000111DF, CHARACTER_FLAG_PRINTABLE },
  // Sinhala Archaic Numbers
  { 0x000111E1, 0x000111F4, CHARACTER_FLAG_PRINTABLE },
  // Khojki
  { 0x00011200, 0x00011211, CHARACTER_FLAG_PRINTABLE },
  { 0x00011213, 0x0001123E, CHARACTER_FLAG_PRINTABLE },
  // Multani
  { 0x00011280, 0x00011286, CHARACTER_FLAG_PRINTABLE },
  { 0x00011288, 0x00011288, CHARACTER_FLAG_PRINTABLE },
  { 0x0001128A, 0x0001128D, CHARACTER_FLAG_PRINTABLE },
  { 0x0001128F, 0x0001129D, CHARACTER_FLAG_PRINTABLE },
  { 0x0001129F, 0x000112A9, CHARACTER_FLAG_PRINTABLE },
  // Khudawadi
  { 0x000112B0, 0x000112EA, CHARACTER_FLAG_PRINTABLE },
  { 0x000112F0, 0x000112F9, CHARACTER_FLAG_PRINTABLE },
  // Grantha
  { 0x00011300, 0x00011303, CHARACTER_FLAG_PRINTABLE },
  { 0x00011305, 0x0001130C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001130F, 0x00011310, CHARACTER_FLAG_PRINTABLE },
  { 0x00011313, 0x00011328, CHARACTER_FLAG_PRINTABLE },
  { 0x0001132A, 0x00011330, CHARACTER_FLAG_PRINTABLE },
  { 0x00011332, 0x00011333, CHARACTER_FLAG_PRINTABLE },
  { 0x00011335, 0x00011339, CHARACTER_FLAG_PRINTABLE },
  { 0x0001133C, 0x00011344, CHARACTER_FLAG_PRINTABLE },
  { 0x00011347, 0x00011348, CHARACTER_FLAG_PRINTABLE },
  { 0x0001134B, 0x0001134D, CHARACTER_FLAG_PRINTABLE },
  { 0x00011350, 0x00011350, CHARACTER_FLAG_PRINTABLE },
  { 0x00011357, 0x00011357, CHARACTER_FLAG_PRINTABLE },
  { 0x00011300, 0x00011303, CHARACTER_FLAG_PRINTABLE },
  { 0x0001135D, 0x00011363, CHARACTER_FLAG_PRINTABLE },
  { 0x00011366, 0x0001136C, CHARACTER_FLAG_PRINTABLE },
  { 0x00011370, 0x00011374, CHARACTER_FLAG_PRINTABLE },
  // Newa
  { 0x00011400, 0x00011459, CHARACTER_FLAG_PRINTABLE },
  { 0x0001145B, 0x0001145B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001145D, 0x0001145D, CHARACTER_FLAG_PRINTABLE },
  // Tirhuta
  { 0x00011480, 0x000114C7, CHARACTER_FLAG_PRINTABLE },
  { 0x000114D0, 0x000114D9, CHARACTER_FLAG_PRINTABLE },
  // Siddham
  { 0x00011580, 0x000115B5, CHARACTER_FLAG_PRINTABLE },
  { 0x000115B8, 0x000115DD, CHARACTER_FLAG_PRINTABLE },
  // Modi
  { 0x00011600, 0x00011644, CHARACTER_FLAG_PRINTABLE },
  { 0x00011650, 0x00011659, CHARACTER_FLAG_PRINTABLE },
  // Mongolian Supplement
  { 0x00011660, 0x0001166C, CHARACTER_FLAG_PRINTABLE },
  // Takri
  { 0x00011680, 0x000116B7, CHARACTER_FLAG_PRINTABLE },
  { 0x000116C0, 0x000116C9, CHARACTER_FLAG_PRINTABLE },
  // Ahom
  { 0x00011700, 0x00011719, CHARACTER_FLAG_PRINTABLE },
  { 0x0001171D, 0x0001172B, CHARACTER_FLAG_PRINTABLE },
  { 0x00011730, 0x0001173F, CHARACTER_FLAG_PRINTABLE },
  // Warang Citi
  { 0x000118A0, 0x000118F2, CHARACTER_FLAG_PRINTABLE },
  { 0x000118FF, 0x000118FF, CHARACTER_FLAG_PRINTABLE },
  // Pau Cin Hau
  { 0x00011AC0, 0x00011AF8, CHARACTER_FLAG_PRINTABLE },
  // Bhaiksuki
  { 0x00011C00, 0x00011C08, CHARACTER_FLAG_PRINTABLE },
  { 0x00011C0A, 0x00011C36, CHARACTER_FLAG_PRINTABLE },
  { 0x00011C38, 0x00011C45, CHARACTER_FLAG_PRINTABLE },
  { 0x00011C50, 0x00011C6C, CHARACTER_FLAG_PRINTABLE },
  // Marchen
  { 0x00011C70, 0x00011C8F, CHARACTER_FLAG_PRINTABLE },
  { 0x00011C92, 0x00011CA7, CHARACTER_FLAG_PRINTABLE },
  { 0x00011CA9, 0x00011CB6, CHARACTER_FLAG_PRINTABLE },
  // Cuneiform
  { 0x00012000, 0x00012399, CHARACTER_FLAG_PRINTABLE },
  // Cuneiform Numbers and Punctuation
  { 0x00012400, 0x0001246E, CHARACTER_FLAG_PRINTABLE },
  { 0x00012470, 0x00012474, CHARACTER_FLAG_PRINTABLE },
  // Early Dynastic Cuneiform
  { 0x00012500, 0x00012543, CHARACTER_FLAG_PRINTABLE },
  // Egyptian Hieroglyphs
  { 0x00013000, 0x0001342E, CHARACTER_FLAG_PRINTABLE },
  // Anatolian Hieroglyphs
  { 0x00014400, 0x00014646, CHARACTER_FLAG_PRINTABLE },
  // Bamum Supplement
  { 0x00016800, 0x00016A38, CHARACTER_FLAG_PRINTABLE },
  // Mro
  { 0x00016A40, 0x00016A5E, CHARACTER_FLAG_PRINTABLE },
  { 0x00016A60, 0x00016A69, CHARACTER_FLAG_PRINTABLE },
  { 0x00016A6E, 0x00016A6F, CHARACTER_FLAG_PRINTABLE },
  // Bassa Vah
  { 0x00016AD0, 0x00016AED, CHARACTER_FLAG_PRINTABLE },
  { 0x00016AF0, 0x00016AF5, CHARACTER_FLAG_PRINTABLE },
  // Pahawh Hmong
  { 0x00016B00, 0x00016B45, CHARACTER_FLAG_PRINTABLE },
  { 0x00016B50, 0x00016B59, CHARACTER_FLAG_PRINTABLE },
  { 0x00016B5B, 0x00016B61, CHARACTER_FLAG_PRINTABLE },
  { 0x00016B63, 0x00016B77, CHARACTER_FLAG_PRINTABLE },
  { 0x00016B7D, 0x00016B8F, CHARACTER_FLAG_PRINTABLE },
  // Miao
  { 0x00016F00, 0x00016F44, CHARACTER_FLAG_PRINTABLE },
  { 0x00016F50, 0x00016F7E, CHARACTER_FLAG_PRINTABLE },
  { 0x00016F8F, 0x00016F9F, CHARACTER_FLAG_PRINTABLE },
  // Ideographic Symbols and Punctuation
  { 0x00016FE0, 0x00016FE0, CHARACTER_FLAG_PRINTABLE },
  // Tangut
  { 0x00017000, 0x000187EC, CHARACTER_FLAG_PRINTABLE },
  // Tangut Components
  { 0x00018800, 0x00018AF2, CHARACTER_FLAG_PRINTABLE },
  // Kana Supplement
  { 0x0001B000, 0x0001B001, CHARACTER_FLAG_PRINTABLE },
  // Duployan
  { 0x0001BC00, 0x0001BC6A, CHARACTER_FLAG_PRINTABLE },
  { 0x0001BC70, 0x0001BC7C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001BC80, 0x0001BC88, CHARACTER_FLAG_PRINTABLE },
  { 0x0001BC90, 0x0001BC99, CHARACTER_FLAG_PRINTABLE },
  // Shorthand Format Controls
  { 0x0001BC9C, 0x0001BCA3, CHARACTER_FLAG_PRINTABLE },
  // Byzantine Musical Symbols
  { 0x0001D000, 0x0001D0F5, CHARACTER_FLAG_PRINTABLE },
  // Musical Symbols
  { 0x0001D100, 0x0001D126, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D129, 0x0001D1E8, CHARACTER_FLAG_PRINTABLE },
  // Ancient Greek Musical Notation
  { 0x0001D200, 0x0001D245, CHARACTER_FLAG_PRINTABLE },
  // Tai Xuan Jing Symbols
  { 0x0001D300, 0x0001D356, CHARACTER_FLAG_PRINTABLE },
  // Counting Rod Numerals
  { 0x0001D360, 0x0001D371, CHARACTER_FLAG_PRINTABLE },
  // Mathematical Alphanumeric Symbols
  { 0x0001D400, 0x0001D454, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D456, 0x0001D49C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D49E, 0x0001D49F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4A2, 0x0001D4A2, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4A5, 0x0001D4A6, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4A9, 0x0001D4AC, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4AE, 0x0001D4B9, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4BB, 0x0001D4BB, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4BD, 0x0001D4C3, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D4C5, 0x0001D505, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D507, 0x0001D50A, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D50D, 0x0001D514, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D516, 0x0001D51C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D51E, 0x0001D539, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D53B, 0x0001D53E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D540, 0x0001D544, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D546, 0x0001D546, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D54A, 0x0001D550, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D552, 0x0001D6A5, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D6A8, 0x0001D7CB, CHARACTER_FLAG_PRINTABLE },
  { 0x0001D7CE, 0x0001D7FF, CHARACTER_FLAG_PRINTABLE },
  // Sutton SignWriting
  { 0x0001D800, 0x0001DA8B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001DA9B, 0x0001DA9F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001DAA0, 0x0001DAAF, CHARACTER_FLAG_PRINTABLE },
  // Glagolitic Supplement
  { 0x0001E000, 0x0001E006, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E008, 0x0001E018, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E01B, 0x0001E021, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E023, 0x0001E024, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E026, 0x0001E02A, CHARACTER_FLAG_PRINTABLE },
  // Mende Kikakui
  { 0x0001E800, 0x0001E8C4, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E8C7, 0x0001E8D6, CHARACTER_FLAG_PRINTABLE },
  // Adlam
  { 0x0001E900, 0x0001E94A, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E950, 0x0001E959, CHARACTER_FLAG_PRINTABLE },
  { 0x0001E95E, 0x0001E95F, CHARACTER_FLAG_PRINTABLE },
  // Arabic Mathematical Alphabetic Symbols
  { 0x0001EE00, 0x0001EE03, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE05, 0x0001EE1F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE21, 0x0001EE22, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE24, 0x0001EE24, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE27, 0x0001EE27, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE29, 0x0001EE32, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE34, 0x0001EE37, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE39, 0x0001EE39, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE3B, 0x0001EE3B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE42, 0x0001EE42, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE47, 0x0001EE47, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE49, 0x0001EE49, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE4B, 0x0001EE4B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE4D, 0x0001EE4F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE51, 0x0001EE52, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE54, 0x0001EE54, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE57, 0x0001EE57, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE59, 0x0001EE59, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE5B, 0x0001EE5B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE5D, 0x0001EE5D, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE5F, 0x0001EE5F, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE61, 0x0001EE62, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE64, 0x0001EE64, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE67, 0x0001EE6A, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE6C, 0x0001EE72, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE74, 0x0001EE77, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE79, 0x0001EE7C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE7E, 0x0001EE7E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE80, 0x0001EE89, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EE8B, 0x0001EE9B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EEA1, 0x0001EEA3, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EEA5, 0x0001EEA9, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EEAB, 0x0001EEBB, CHARACTER_FLAG_PRINTABLE },
  { 0x0001EEF0, 0x0001EEF1, CHARACTER_FLAG_PRINTABLE },
  // Mahjong Tiles
  { 0x0001F000, 0x0001F02B, CHARACTER_FLAG_PRINTABLE },
  // Domino Tiles
  { 0x0001F030, 0x0001F093, CHARACTER_FLAG_PRINTABLE },
  // Playing Cards
  { 0x0001F0A0, 0x0001F0AE, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F0B1, 0x0001F0BF, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F0C1, 0x0001F0CF, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F0C1, 0x0001F0DF, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F0E0, 0x0001F0F5, CHARACTER_FLAG_PRINTABLE },
  // Enclosed Alphanumeric Supplement
  { 0x0001F100, 0x0001F10C, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F110, 0x0001F12E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F130, 0x0001F16B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F170, 0x0001F1AC, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F1E6, 0x0001F202, CHARACTER_FLAG_PRINTABLE },
  // Enclosed Ideographic Supplement
  { 0x0001F210, 0x0001F23B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F240, 0x0001F248, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F250, 0x0001F251, CHARACTER_FLAG_PRINTABLE },
  // Miscellaneous Symbols and Pictographs, Emoticons, Ornamental Dingbats, Transport and Map Symbols
  { 0x0001F300, 0x0001F6D2, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F6E0, 0x0001F6EC, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F6F0, 0x0001F6F6, CHARACTER_FLAG_PRINTABLE },
  // Alchemical Symbols
  { 0x0001F700, 0x0001F773, CHARACTER_FLAG_PRINTABLE },
  // Geometric Shapes Extended
  { 0x0001F780, 0x0001F7D4, CHARACTER_FLAG_PRINTABLE },
  // Supplemental Arrows-C
  { 0x0001F080, 0x0001F80B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F810, 0x0001F847, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F850, 0x0001F859, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F860, 0x0001F887, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F890, 0x0001F8AD, CHARACTER_FLAG_PRINTABLE },
  // Supplemental Symbols and Pictographs
  { 0x0001F910, 0x0001F91E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F920, 0x0001F927, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F930, 0x0001F930, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F933, 0x0001F93E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F940, 0x0001F94B, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F950, 0x0001F95E, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F980, 0x0001F991, CHARACTER_FLAG_PRINTABLE },
  { 0x0001F9C0, 0x0001F9C0, CHARACTER_FLAG_PRINTABLE },
  // CJK Unified Ideographs Extension B
  { 0x00020000, 0x0002A6D6, CHARACTER_FLAG_PRINTABLE },
  // CJK Unified Ideographs Extension C
  { 0x0002A700, 0x0002B734, CHARACTER_FLAG_PRINTABLE },
  // CJK Unified Ideographs Extension D
  { 0x0002B740, 0x0002B81D, CHARACTER_FLAG_PRINTABLE },
  // CJK Unified Ideographs Extension E
  { 0x0002B820, 0x0002CEA1, CHARACTER_FLAG_PRINTABLE },
  // CJK Compatibility Ideographs Supplement
  { 0x0002F800, 0x0002FA1D, CHARACTER_FLAG_PRINTABLE }
};

// StringLibInitialize
/// String  library initialize use
/// @return Whether the library initialized successfully or not
/// @retval EFI_SUCCESS The library successfully initialized
STATIC
VOID
EFIAPI
InternalStringInitialize (
  VOID
) {
  STATIC BOOLEAN NotInitialized = TRUE;
  // Initialize the default english collation
  if (NotInitialized) {
    UINTN Index;
    UINTN Index2;
    // Initialize unicode collation for english as fallback
    for (Index = 0; Index < MAP_TABLE_SIZE; ++Index) {
      mEngUpperMap[Index] = (CHAR8)Index;
      mEngLowerMap[Index] = (CHAR8)Index;
      mEngInfoMap[Index]  = 0;

      if (((Index >= 'a') && (Index <= 'z')) || ((Index >= 0xe0) && (Index <= 0xf6)) || ((Index >= 0xf8) && (Index <= 0xfe))) {

        Index2 = (Index - 0x20);
        mEngUpperMap[Index] = (CHAR8)Index2;
        mEngLowerMap[Index2] = (CHAR8)Index;

        mEngInfoMap[Index] |= CHAR_FAT_VALID;
        mEngInfoMap[Index2] |= CHAR_FAT_VALID;
      }
    }
    for (Index = 0; mOtherChars[Index] != 0; Index++) {
      Index2 = mOtherChars[Index];
      mEngInfoMap[Index2] |= CHAR_FAT_VALID;
    }
    NotInitialized = FALSE;
  }
}

// IsUnicodeCharacter
/// Check if character is valid unicode code point
/// @param Character The character to check is valid
/// @retval TRUE  If the character is a valid unicode code point
/// @retval FALSE If the character is invalid in unicode
BOOLEAN
EFIAPI
IsUnicodeCharacter (
  IN UINT32 Character
) {
  UINTN Index;
  for (Index = 0; Index < ARRAY_COUNT(mValidCharRanges); ++Index) {
    if (Character < mValidCharRanges[Index].Start) {
      break;
    }
    if (Character <= mValidCharRanges[Index].End) {
      return TRUE;
    }
  }
  return FALSE;
}
// IsUnicodePrintCharacter
/// Check if character is valid printable unicode code point
/// @param Character The character to check is valid
/// @retval TRUE  If the character is a valid unicode code point
/// @retval FALSE If the character is invalid in unicode
BOOLEAN
EFIAPI
IsUnicodePrintCharacter (
  IN UINT32 Character
) {
  UINTN Index;
  if (Character == 0) {
    return FALSE;
  }
  for (Index = 0; Index < ARRAY_COUNT(mValidCharRanges); ++Index) {
    if (Character < mValidCharRanges[Index].Start) {
      break;
    }
    if (Character <= mValidCharRanges[Index].End) {
      return (EFI_BITS_ANY_SET(mValidCharRanges[Index].Flags, CHARACTER_FLAG_PRINTABLE));
    }
  }
  return FALSE;
}

// StrLen
/// Get the length of a character string
/// @param Str The character string
/// @return The count of characters in the character string
UINTN
EFIAPI
StrLen (
  CONST CHAR16 *Str
) {
  CONST CHAR16 *Ptr = Str;
  if (Str == NULL) {
    return NULL;
  }
  while (*Ptr != 0) {
    ++Ptr;
  }
  return Ptr - Str;
}
// StrSize
/// Get the size in bytes of a character string (including the null-terminator)
/// @param Str The character string of which to get the size
/// @return The size in bytes of the character string (including the null-terminator)
UINTN
EFIAPI
StrSize (
  CONST CHAR16 *Str
) {
  CONST CHAR16 *Ptr = Str;
  if (Str == NULL) {
    return NULL;
  }
  while (*Ptr++ != 0);
  return sizeof(CHAR16) * (Ptr - Str);
}

// StrDup
/// Duplicate a string
/// @param Str The string to duplicate
/// @return The duplicated string which needs freed or NULL if the string could not be duplicate
CHAR16 *
EFIAPI
StrDup (
  IN CONST CHAR16 *Str
) {
  CHAR16 *Dup;
  UINTN   Len;
  // Check string is valid
  if (Str == NULL) {
    return NULL;
  }
  // Duplicate memory for string
  Len = StrLen(Str) + 1;
  Dup = EfiAllocateArray(CHAR16, Len);
  if (Dup != NULL) {
    // Copy the string to duplicate
    EfiCopyArray(CHAR16, Dup, Str, Len);
  }
  // Return duplicate
  return Dup;
}
// StrnDup
/// Duplicate a string
/// @param Str   The string to duplicate
/// @param Count The maximum count of characters to duplicate
/// @return The duplicated string which needs freed or NULL if the string could not be duplicate
CHAR16 *
EFIAPI
StrnDup (
  IN CONST CHAR16 *Str,
  IN UINTN         Count
) {
  CHAR16 *Dup;
  UINTN   Len;
  // Check string is valid
  if ((Str == NULL) || (Count == 0)) {
    return NULL;
  }
  // Duplicate memory for string
  Len = StrLen(Str);
  if (Len > Count) {
    Len = Count;
  }
  Dup = EfiAllocateArray(CHAR16, ++Len);
  if (Dup != NULL) {
    // Copy the string to duplicate
    EfiCopyArray(CHAR16, Dup, Str, Len);
    Dup[Len - 1] = 0;
  }
  // Return duplicate
  return Dup;
}

// StrCmp
/// Performs a comparison of two strings
/// @param Str1 The first string to comapre
/// @param Str2 The second string to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
StrCmp (
  IN CONST CHAR16 *Str1,
  IN CONST CHAR16 *Str2
) {
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  while (*Str1 != 0) {
    if (*Str1 != *Str2) {
      break;
    }
    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// StrnCmp
/// Performs a comparison of two strings
/// @param Str1  The first string to comapre
/// @param Str2  The second string to compare
/// @param Count The maximum count of characters to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
StrnCmp (
  IN CONST CHAR16 *Str1,
  IN CONST CHAR16 *Str2,
  IN UINTN         Count
) {
  // Check parameters
  if (Count == 0) {
    return 0;
  }
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  while ((*Str1 != 0) && (*Str1 == *Str2) && (Count-- > 1)) {
    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// StriCmp
/// Performs a case-insensitive comparison of two strings
/// @param Str1 The first string to comapre
/// @param Str2 The second string to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
StriCmp (
  IN CONST CHAR16 *Str1,
  IN CONST CHAR16 *Str2
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->StriColl != NULL)) {
    return Protocol->StriColl(Protocol, (CHAR16 *)Str1, (CHAR16 *)Str2);
  }
  // Fallback to english collation
  InternalStringInitialize();
  while (*Str1 != 0) {
    if (TO_UPPER(*Str1) != TO_UPPER(*Str2)) {
      break;
    }
    ++Str1;
    ++Str2;
  }
  return TO_UPPER(*Str1) - TO_UPPER(*Str2);
}
// StrniCmp
/// Performs a case-insensitive comparison of two strings
/// @param Str1  The first string to comapre
/// @param Str2  The second string to compare
/// @param Count The maximum count of characters to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
StrniCmp (
  IN CONST CHAR16 *Str1,
  IN CONST CHAR16 *Str2,
  IN UINTN         Count
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  // Check parameters
  if (Count == 0) {
    return 0;
  }
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->StriColl != NULL)) {
    INTN    Result;
    CHAR16 *StrCopy1;
    CHAR16 *StrCopy2;
    // Duplicate the revelant part of the first string
    StrCopy1 = StrnDup(Str1, Count);
    if (StrCopy1 == NULL) {
      return EFI_OUT_OF_RESOURCES;
    }
    // Duplicate the revelant part of the second string
    StrCopy2 = StrnDup(Str2, Count);
    if (StrCopy2 == NULL) {
      EfiFreePool(StrCopy1);
      return EFI_OUT_OF_RESOURCES;
    }
    // Collate the string copies
    Result = Protocol->StriColl(Protocol, (CHAR16 *)StrCopy1, (CHAR16 *)StrCopy2);
    // Free the string copies and return the result
    EfiFreePool(StrCopy1);
    EfiFreePool(StrCopy2);
    return Result;
  }
  InternalStringInitialize();
  while ((*Str1 != 0) && (TO_UPPER(*Str1) == TO_UPPER(*Str2)) && (Count-- > 1)) {
    ++Str1;
    ++Str2;
  }
  return TO_UPPER(*Str1) - TO_UPPER(*Str2);
}

// StriColl
/// Performs a case-insensitive collation of two strings
/// @param Str1 The first string to collate
/// @param Str2 The second string to collate
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
StriColl (
  IN CONST CHAR16 *Str1,
  IN CONST CHAR16 *Str2
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->StriColl != NULL)) {
    INTN Result = Protocol->StriColl(Protocol, (CHAR16 *)Str1, (CHAR16 *)Str2);
    if (Result == 0) {
      // For the case insensitive comparison of the strings is the same then do case sensitive comparison
      Result = StrCmp(Str1, Str2);
    }
    return Result;
  }
  // Fallback to english collation
  InternalStringInitialize();
  while (*Str1 != 0) {
    if ((TO_UPPER(*Str1) != TO_UPPER(*Str2)) || (*Str1 != *Str2)) {
      break;
    }
    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// MetaiMatch
/// Performs a case-insensitive comparison of a pattern string and a string
/// @param String  A pointer to a string
/// @param Pattern A pointer to a pattern string
/// @retval TRUE  Pattern was found in String
/// @retval FALSE Pattern was not found in String
BOOLEAN
EFIAPI
MetaiMatch (
  IN CONST CHAR16 *String,
  IN CONST CHAR16 *Pattern
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  CHAR16  CharC;
  CHAR16  CharP;
  CHAR16  Index3;
  // Check parameters
  if ((String == NULL) || (Pattern == NULL)) {
    return FALSE;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->MetaiMatch != NULL)) {
    return Protocol->MetaiMatch(Protocol, (CHAR16 *)String, (CHAR16 *)Pattern);
  }
  // Fallback to english collation
  InternalStringInitialize();
  while ((CharP = *Pattern++) != '\0') {

    switch (CharP) {

    case '*':
      // Match zero or more chars
      while (*String != 0) {
        if (MetaiMatch(String, Pattern)) {
          return TRUE;
        }
        ++String;
      }

      return MetaiMatch(String, Pattern);

    case '?':
      // Match any one char
      if (*String == 0) {
        return FALSE;
      }
      ++String;
      break;

    case '[':
      // Match char set
      CharC = *String;
      if (CharC == 0) {
        // syntax problem
        return FALSE;
      }

      Index3 = 0;
      CharP = *Pattern++;
      while (CharP != 0) {
        if (CharP == ']') {
          return FALSE;
        }
        if (CharP == '-') {
          // if range of chars, get high range
          CharP = *Pattern;
          if (CharP == 0 || CharP == ']') {
            // syntax problem
            return FALSE;
          }
          if ((TO_UPPER(CharC) >= TO_UPPER(Index3)) && (TO_UPPER(CharC) <= TO_UPPER(CharP))) {
            // if in range, it's a match
            break;
          }
        }
        Index3 = CharP;
        if (TO_UPPER(CharC) == TO_UPPER(CharP)) {
          // if char matches
          break;
        }

        CharP = *Pattern++;
      }
      // skip to end of match char set
      while ((CharP != 0) && (CharP != ']')) {
        CharP = *Pattern++;
      }
      ++String;
      break;

    default:
      CharC = *String;
      if (TO_UPPER(CharC) != TO_UPPER(CharP)) {
        return FALSE;
      }
      ++String;
      break;

    }
  }
  return (*String == L'\0');
}

// StrLwr
/// Converts all the characters in a string to lower case characters
/// @param Str A pointer to a string
VOID
EFIAPI
StrLwr (
  IN OUT CHAR16 *Str
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  if (Str == NULL) {
    return;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->StrLwr != NULL)) {
    Protocol->StrLwr(Protocol, Str);
  } else {
    // Fallback to english collation
    InternalStringInitialize();
    while (*Str != 0) {
      *Str = TO_LOWER(*Str);
      ++Str;
    }
  }
}
// StrUpr
/// Converts all the characters in a string to upper case characters
/// @param Str A pointer to a string
VOID
EFIAPI
StrUpr (
  IN OUT CHAR16 *Str
) {
  EFI_UNICODE_COLLATION_PROTOCOL *Protocol;
  if (Str == NULL) {
    return;
  }
  // Use collation protocol if present
  Protocol = EfiGetLanguageCollationProtocol(NULL);
  if ((Protocol != NULL) && (Protocol->StrUpr != NULL)) {
    Protocol->StrUpr(Protocol, Str);
  } else {
    // Fallback to english collation
    InternalStringInitialize();
    while (*Str != 0) {
      *Str = TO_UPPER(*Str);
      ++Str;
    }
  }
}

// StrToLower
/// Duplicates all the characters in a string to lower case characters
/// @param Str A pointer to a string
/// @return A duplicate string with all lower case characters, which must be freed or NULL if there was an error
CHAR16 *
EFIAPI
StrToLower (
  IN CONST CHAR16 *Str
) {
  CHAR16 *Dup = StrDup(Str);
  if (Dup != NULL) {
    StrLwr(Dup);
  }
  return Dup;
}
// StrToUpper
/// Duplicates all the characters in a string to upper case characters
/// @param Str A pointer to a string
/// @return A duplicate string with all upper case characters, which must be freed or NULL if there was an error
CHAR16 *
EFIAPI
StrToUpper (
  IN CONST CHAR16 *Str
) {
  CHAR16 *Dup = StrDup(Str);
  if (Dup != NULL) {
    StrUpr(Dup);
  }
  return Dup;
}

// StrStr
/// Returns the first occurrence of a sub-string in a string
/// @param String       A pointer to a string
/// @param SearchString A pointer to a string for which to search
/// @return A pointer to the matched sub-string in String
/// @retval NULL If SearchString was not found in String
CHAR16 *
EFIAPI
StrStr (
  IN CHAR16 *String,
  IN CHAR16 *SearchString
) {
  // Check parameters
  if (String == NULL) {
    return NULL;
  }
  if ((SearchString == NULL) || (*SearchString == L'\0')) {
    return String;
  }
  // Iterate through string for matches
  while (*String != L'\0') {
    CHAR16 *SearchStringTmp = SearchString;
    CHAR16 *FirstMatch = String;

    // Check for match
    while ((*String == *SearchStringTmp) && (*String != L'\0')) {
      ++String;
      ++SearchStringTmp;
    }

    if (*SearchStringTmp == L'\0') {
      // Found
      return FirstMatch;
    }
    if (*String == L'\0') {
      // Not found
      return NULL;
    }

    String = FirstMatch + 1;
  }
  // Not found
  return NULL;
}
// StriStr
/// Returns the first occurrence of a case-insensitive sub-string in a string
/// @param String       A pointer to a string
/// @param SearchString A pointer to a string for which to search
/// @return A pointer to the matched sub-string in String
/// @retval NULL If SearchString was not found in String
CHAR16 *
EFIAPI
StriStr (
  IN CHAR16 *String,
  IN CHAR16 *SearchString
) {
  UINTN StringLen = StrLen(String);
  UINTN SearchLen = StrLen(SearchString);
  // Check parameters
  if (String == NULL) {
    return NULL;
  }
  if ((SearchString == NULL) || (*SearchString == L'\0')) {
    return String;
  }
  // Iterate through string for matches
  while ((StringLen >= SearchLen) && (*String != L'\0')) {
    // Check for match
    if (StrniCmp(String, SearchString, SearchLen) == 0) {
      return String;
    }
    // Advance string and decrement remaining string length
    ++String;
    --StringLen;
  }
  // Not found
  return NULL;
}

// StrAppend
/// Append a character to a string
/// @param String    On input, the string to which to append or NULL to allocate a new string, on output, the possibly reallocated string, which needs freed
/// @param Count     On input, the length count, in characters, of the string, on output, the length count, in characters, of the string
/// @param Size      On input, the allocated size, in characters, of the string, on output, the allocated size, in characters, of the string
/// @param Character The character to append to the string
/// @return Whether the character was appended to the string or not
/// @retval EFI_INVALID_PARAMETER If String, Count, or Size is NULL or Character is invalid or *Count >= *Size
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated for the string
/// @retval EFI_SUCCESS           If the character was appended to the string successfully
EFI_STATUS
EFIAPI
StrAppend (
  IN OUT CHAR16 **String,
  IN OUT UINTN   *Count,
  IN OUT UINTN   *Size,
  IN     UINT32   Character
) {
  EFI_ENCODING_PROTOCOL *Encoding;
  // Get the UTF-16 encoding protocol
  Encoding = EfiUtf16Encoding();
  if (Encoding == NULL) {
    return EFI_UNSUPPORTED;
  }
  return EfiAppendCharacter(Encoding, (VOID **)String, Count, Size, Character);
}

// StrSplit
/// Split a string into a list
/// @param List    On output, the string list, which must be freed with StrListFree
/// @param Count   On output, the count of strings in the list
/// @param Str     The string to split
/// @param Split   The string that splits
/// @param Options The options for the string list
/// @return Whether the string was split or not
/// @retval EFI_INVALID_PARAMETER If List, Count, Str, or Split is NULL or *List is not NULL
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated for the string list
/// @retval EFI_NOT_FOUND         If the split string could not be found
/// @retval EFI_SUCCESS           If the string was split into a list successfully
EFI_STATUS
EFIAPI
StrSplit (
  OUT CHAR16 ***List,
  OUT UINTN    *Count,
  IN  CHAR16   *Str,
  IN  CHAR16   *Split,
  IN  UINTN     Options
) {
  CHAR16  *NextStr;
  CHAR16 **NewList;
  UINTN    NewCount;
  UINTN    Length;
  // Check parameters
  if ((List == NULL) || (*List != NULL) || (Count == NULL) || (Str == NULL) || (Split == NULL)) {
    return EFI_INVALID_PARAMETER;
  }
  Length = StrLen(Split);
  if (Length == 0) {
    return EFI_INVALID_PARAMETER;
  }
  if (Length > StrLen(Str)) {
    return EFI_NOT_FOUND;
  }
  // Start new string list
  NewList = NULL;
  NewCount = 0;
  // Iterate through the string
  do {
    // Get next instance of split string
    if (EFI_BITS_ANY_SET(Options, STR_SEARCH_CASE_INSENSITIVE)) {
      NextStr = StriStr(Str, Split);
    } else {
      NextStr = StrStr(Str, Split);
    }
    // Check if the split string was found
    if (NextStr == NULL) {
      if (NewCount == 0) {
        // No split string found
        return EFI_NOT_FOUND;
      }
      // Last string so done splitting
      StrList(&NewList, &NewCount, Str, 0, Options);
      break;
    }
    // Add string to list
    StrList(&NewList, &NewCount, Str, NextStr - Str, Options);
    // Advance string
    Str = NextStr + Length;
  // If we reach the null terminator then done splitting
  } while (*Str != '\0');

  // Return list and count
  *List = NewList;
  *Count = NewCount;
  return EFI_SUCCESS;
}
// StrList
/// Append a string to a list
/// @param List    The list to append the string, which must be freed with StrListFree, *List may be NULL to start new list
/// @param Count   The current count of strings in the list
/// @param Str     The string to append to the list
/// @param Length  The maximum length of the string or zero to use the entire string
/// @param Options The options for adding the strings
/// @return Whether the string was added to the list or not
/// @retval EFI_INVALID_PARAMETER If List, Count, or Str is NULL
/// @retval EFI_OUT_OF_RESOURCES  If the memory for the list could not be allocated
/// @retval EFI_ACCESS_DENIED     If STR_LIST_NO_DUPLICATES was used and the string already exists
/// @retval EFI_SUCCESS           If the string was added to the list successfully
EFI_STATUS
EFIAPI
StrList (
  IN OUT CHAR16 ***List,
  IN OUT UINTN    *Count,
  IN     CHAR16   *Str,
  IN     UINTN     Length,
  IN     UINTN     Options
) {
  CHAR16  *NewStr;
  CHAR16 **NewList;
  CHAR16 **InitialList;
  UINTN    InitialCount;
  UINTN    NewCount;
  UINTN    Index;

  // Check parameters
  if ((List == NULL) || (Count == NULL) || (Str == NULL)) {
    return EFI_INVALID_PARAMETER;
  }
  // Get the initial list and count
  InitialList = *List;
  InitialCount = (InitialList == NULL) ? 0 : *Count;
  // Check for duplicates if needed
  if (EFI_BITS_ANY_SET(Options, STR_LIST_NO_DUPLICATES)) {
    // Check case insensitively if needed
    if (EFI_BITS_ANY_SET(Options, STR_LIST_CASE_INSENSITIVE)) {
      // Check for duplicates case insensitively
      for (Index = 0; Index < InitialCount; ++Index) {
        if (StriCmp(InitialList[Index], Str) == 0) {
          // Already in list
          return EFI_ACCESS_DENIED;
        }
      }
    } else {
      // Check for duplicates
      for (Index = 0; Index < InitialCount; ++Index) {
        if (StrCmp(InitialList[Index], Str) == 0) {
          // Already in list
          return EFI_ACCESS_DENIED;
        }
      }
    }
  }
  // Duplicate the string
  NewStr = (Length == 0) ? StrDup(Str) : StrnDup(Str, Length);
  if (NewStr == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  // Reallocate size in the list for one more string
  NewCount = InitialCount + 1;
  NewList = EfiAllocateArray(CHAR16 *, NewCount);
  if (NewList == NULL) {
    EfiFreePool(NewStr);
    return EFI_OUT_OF_RESOURCES;
  }
  // Check if the string list is sorted
  if (EFI_BITS_ANY_SET(Options, STR_LIST_SORTED)) {
    // Determine insertion point with binary search
    UINTN Left = 0;
    UINTN Right = InitialCount;
    Index = 0;
    while (Left < Right) {
      Index = Left + ((Right - Left) >> 1);
      if (StriColl(InitialList[Index], NewStr) < 0) {
        Left = ++Index;
      } else {
        Right = Index;
      }
    }
    // Copy old list before insertion point
    if (Index > 0) {
      EfiCopyArray(CHAR16, NewList, InitialList, Index);
    }
    // Insert string into list
    NewList[Index] = NewStr;
    // Copy after insertion point
    if (Index < InitialCount) {
      EfiCopyArray(CHAR16 *, NewList + Index + 1, InitialList + Index, InitialCount - Index);
    }
  } else {
    // Copy old list
    EfiCopyArray(CHAR16, NewList, InitialList, InitialCount);
    EfiFreePool(InitialList);
    // Append string to list
    NewList[InitialCount] = NewStr;
  }
  // Set new list and count
  *List = NewList;
  *Count = NewCount;
  return EFI_SUCCESS;
}
// StrListDup
/// Duplicate a string list
/// @param Duplicate On output, the duplicated string list which must be free with StrListFree
/// @param Count     The count of strings
/// @param List      The string list to duplicate
/// @return Whether the string list was duplicated or not
/// @return EFI_INVALID_PARAMETER If Duplicate or List is NULL or *Duplicate is not NULL or Count is zero
/// @return EFI_OUT_OF_RESOURCES  If memory could not be allocated
/// @return EFI_SUCCESS           If the string list was duplicated successfully
EFI_STATUS
EFIAPI
StrListDup (
  OUT CHAR16 ***Duplicate,
  IN  UINTN     Count,
  IN  CHAR16  **List
) {
  CHAR16 **NewList;
  UINTN    Index;
  // Check parameters
  if ((Duplicate == NULL) || (List == NULL) || (Count == 0)) {
    return EFI_INVALID_PARAMETER;
  }
  // Allocate a new list
  NewList = EfiAllocateArray(CHAR16 *, Count);
  if (NewList == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  // Duplicate strings
  for (Index = 0; Index < Count; ++Index) {
    NewList[Index] = StrDup(List[Index]);
  }
  // Return duplicate string list
  *Duplicate = NewList;
  return EFI_SUCCESS;
}
// StrListFree
/// Free a string list
/// @param List  The string list to free
/// @param Count The count of strings in the list
/// @return Whether the string list was freed or not
/// @return EFI_INVALID_PARAMETER If List is NULL or Count is zero
/// @return EFI_SUCCESS           If the string list was freed successfully
EFI_STATUS
EFIAPI
StrListFree (
  IN CHAR16 **List,
  IN UINTN    Count
) {
  UINTN Index;
  // Check parameters
  if ((List == NULL) || (Count == 0)) {
    return EFI_INVALID_PARAMETER;
  }
  // Free each string
  for (Index = 0; Index < Count; ++Index) {
    EfiFreePool(List[Index]);
  }
  // Free the list
  EfiFreePool(List);
  return EFI_SUCCESS;
}

// StrToBoolean
/// Convert a string to boolean
/// @param Str     On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Boolean On output, the converted boolean value
/// @retval EFI_INVALID_PARAMETER If Str, *Str, or Boolean is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
StrToBoolean (
  IN OUT CONST CHAR16 **Str,
  OUT    BOOLEAN       *Boolean
) {
  return EfiEncodingToBoolean(EfiUtf16Encoding(), (VOID **)Str, NULL, Boolean);
}
// StrToUnsigned
/// Convert a string to unsigned
/// @param Str      On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Unsigned On output, the converted unsigned value
/// @param Base     The base of the integer (usually 10 for decimal)
/// @retval EFI_INVALID_PARAMETER If Unsigned is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
StrToUnsigned (
  IN OUT CONST CHAR16 **Str,
  OUT    UINT64        *Unsigned,
  IN     UINTN          Base
) {
  return EfiEncodingToUnsigned(EfiUtf16Encoding(), (VOID **)Str, NULL, Unsigned, Base);
}
// StrToInteger
/// Convert a string to integer
/// @param Str     On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Integer On output, the converted integer value
/// @param Base    The base of the integer (usually 10 for decimal)
/// @retval EFI_INVALID_PARAMETER If Integer is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
StrToInteger (
  IN OUT CONST CHAR16 **Str,
  OUT    INT64         *Integer,
  IN     UINTN          Base
) {
  return EfiEncodingToInteger(EfiUtf16Encoding(), (VOID **)Str, NULL, Integer, Base);
}
// StrToFloat
/// Convert a string to a floating point
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Float On output, the converted float value
/// @retval EFI_INVALID_PARAMETER If Float is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
StrToFloat (
  IN OUT CONST CHAR16 **Str,
  OUT    FLOAT64       *Float
) {
  return EfiEncodingToFloat(EfiUtf16Encoding(), (VOID **)Str, NULL, Float);
}
// StrToDateTime
/// Convert a date and/or time formatted character string buffer to a date and time
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param DateTime On output, the converted date and time
/// @retval EFI_INVALID_PARAMETER  If This, Encoding, Buffer, *Buffer, or DateTime is NULL
/// @retval EFI_NOT_FOUND          If the buffer is not valid for conversion
/// @retval EFI_SUCCESS            If the buffer was converted to a floating point successfully
EFI_STATUS
EFIAPI
StrToDateTime (
  IN OUT CONST CHAR16 **Str,
  IN OUT EFI_TIME      *DateTime
) {
  return EfiEncodingToDateTime(EfiUtf16Encoding(), (VOID **)Str, NULL, DateTime);
}
// StrToGuid
/// Convert a GUID formatted character string buffer to a GUID
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Guid  On output, the converted GUID
/// @retval EFI_INVALID_PARAMETER  If This, Encoding, Buffer, *Buffer, or Guid is NULL
/// @retval EFI_NOT_FOUND          If the buffer is not valid for conversion
/// @retval EFI_SUCCESS            If the buffer was converted to a GUID successfully
EFI_STATUS
EFIAPI
StrToGuid (
  IN OUT CONST CHAR16 **Str,
  IN OUT EFI_GUID      *Guid
) {
  return EfiEncodingToGuid(EfiUtf16Encoding(), (VOID **)Str, NULL, Guid);
}

// StrToAscii
/// Convert UTF-16 to UTF-8
/// @param String The UTF-16 string to convert
/// @return The converted UTF-8 string
CHAR8 *
EFIAPI
StrToAscii (
  IN CONST CHAR16 *String
) {
  return (CHAR8 *)EfiEncodingPoolConvert(EfiUtf8Encoding(), NULL, EfiUtf16Encoding(), (VOID *)String, StrSize(String));
}
// StrFromAscii
/// Convert UTF-16 to UTF-8
/// @param String The UTF-16 string to convert
/// @return The converted UTF-8 string
CHAR16 *
EFIAPI
StrFromAscii (
  IN CONST CHAR8 *String
) {
  return (CHAR16 *)EfiEncodingPoolConvert(EfiUtf16Encoding(), NULL, EfiUtf8Encoding(), (VOID *)String, AsciiStrSize(String));
}

// AsciiStrLen
/// Get the length of a character string
/// @param Str The character string
/// @return The count of characters in the character string
UINTN
EFIAPI
AsciiStrLen (
  CONST CHAR8 *Str
) {
  CONST CHAR8 *Ptr = Str;
  if (Str == NULL) {
    return NULL;
  }
  while (*Ptr != 0) {
    ++Ptr;
  }
  return Ptr - Str;
}
// AsciiStrSize
/// Get the size in bytes of a character string (including the null-terminator)
/// @param Str The character string of which to get the size
/// @return The size in bytes of the character string (including the null-terminator)
UINTN
EFIAPI
AsciiStrSize (
  CONST CHAR8 *Str
) {
  CONST CHAR8 *Ptr = Str;
  if (Str == NULL) {
    return NULL;
  }
  while (*Ptr++ != 0);
  return sizeof(CHAR8) * (Ptr - Str);
}

// AsciiStrDup
/// Duplicate a string
/// @param Str The string to duplicate
/// @return The duplicated string which needs freed or NULL if the string could not be duplicate
CHAR8 *
EFIAPI
AsciiStrDup (
  IN CONST CHAR8 *Str
) {
  CHAR8 *Dup;
  UINTN  Len;
  // Check string is valid
  if (Str == NULL) {
    return NULL;
  }
  // Duplicate memory for string
  Len = AsciiStrLen(Str) + 1;
  Dup = EfiAllocateArray(CHAR8, Len);
  if (Dup != NULL) {
    // Copy the string to duplicate
    EfiCopyArray(CHAR8, Dup, Str, Len);
  }
  // Return duplicate
  return Dup;
}
// AsciiStrnDup
/// Duplicate a string
/// @param Str   The string to duplicate
/// @param Count The maximum count of characters to duplicate
/// @return The duplicated string which needs freed or NULL if the string could not be duplicate
CHAR8 *
EFIAPI
AsciiStrnDup (
  IN CONST CHAR8 *Str,
  IN UINTN        Count
) {
  CHAR8 *Dup;
  UINTN  Len;
  // Check string is valid
  if ((Str == NULL) || (Count == 0)) {
    return NULL;
  }
  // Duplicate memory for string
  Len = AsciiStrLen(Str);
  if (Len > Count) {
    Len = Count;
  }
  Dup = EfiAllocateArray(CHAR8, ++Len);
  if (Dup != NULL) {
    // Copy the string to duplicate
    EfiCopyArray(CHAR8, Dup, Str, Len);
    Dup[Len - 1] = 0;
  }
  // Return duplicate
  return Dup;
}

// AsciiStrCmp
/// Performs a comparison of two strings
/// @param Str1 The first string to comapre
/// @param Str2 The second string to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
AsciiStrCmp (
  IN CONST CHAR8 *Str1,
  IN CONST CHAR8 *Str2
) {
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  while (*Str1 != 0) {
    if (*Str1 != *Str2) {
      break;
    }
    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// AsciiStrnCmp
/// Performs a comparison of two strings
/// @param Str1  The first string to comapre
/// @param Str2  The second string to compare
/// @param Count The maximum count of characters to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
AsciiStrnCmp (
  IN CONST CHAR8 *Str1,
  IN CONST CHAR8 *Str2,
  IN UINTN         Count
) {
  // Check parameters
  if (Count == 0) {
    return 0;
  }
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  while ((*Str1 != 0) && (*Str1 == *Str2) && (Count-- > 1)) {
    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// AsciiStriCmp
/// Performs a case-insensitive comparison of two strings
/// @param Str1 The first string to comapre
/// @param Str2 The second string to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
AsciiStriCmp (
  IN CONST CHAR8 *Str1,
  IN CONST CHAR8 *Str2
) {
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  InternalStringInitialize();
  while (*Str1 != 0) {
    if (TO_UPPER(*Str1) != TO_UPPER(*Str2)) {
      break;
    }
    ++Str1;
    ++Str2;
  }
  return TO_UPPER(*Str1) - TO_UPPER(*Str2);
}
// AsciiStrniCmp
/// Performs a case-insensitive comparison of two strings
/// @param Str1  The first string to comapre
/// @param Str2  The second string to compare
/// @param Count The maximum count of characters to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
AsciiStrniCmp (
  IN CONST CHAR8 *Str1,
  IN CONST CHAR8 *Str2,
  IN UINTN        Count
) {
  // Check parameters
  if (Count == 0) {
    return 0;
  }
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  InternalStringInitialize();
  while ((*Str1 != 0) && (TO_UPPER(*Str1) == TO_UPPER(*Str2)) && (Count-- > 1)) {
    ++Str1;
    ++Str2;
  }
  return TO_UPPER(*Str1) - TO_UPPER(*Str2);
}

// AsciiStriColl
/// Performs a case-insensitive comparison of two strings
/// @param Str1 The first string to comapre
/// @param Str2 The second string to compare
/// @retval 0  Str1 is equivalent to Str2
/// @retval >0 Str1 is lexically greater than Str2
/// @retval <0 Str1 is lexically less than Str2
INTN
EFIAPI
AsciiStriColl (
  IN CONST CHAR8 *Str1,
  IN CONST CHAR8 *Str2
) {
  if (Str1 == NULL) {
    if (Str2 == NULL) {
      return 0;
    }
    return -1;
  } else if (Str2 == NULL) {
    return 1;
  }
  InternalStringInitialize();
  while (*Str1 != 0) {
    if ((TO_UPPER(*Str1) != TO_UPPER(*Str2)) || (*Str1 != *Str2)) {
      break;
    }

    ++Str1;
    ++Str2;
  }
  return *Str1 - *Str2;
}
// AsciiMetaiMatch
/// Performs a case-insensitive comparison of a pattern string and a string
/// @param String  A pointer to a string
/// @param Pattern A pointer to a pattern string
/// @retval TRUE  Pattern was found in String
/// @retval FALSE Pattern was not found in String
BOOLEAN
EFIAPI
AsciiMetaiMatch (
  IN CONST CHAR8 *String,
  IN CONST CHAR8 *Pattern
) {
  CHAR8 CharC;
  CHAR8 CharP;
  CHAR8 Index3;
  // Check parameters
  if ((String == NULL) || (Pattern == NULL)) {
    return FALSE;
  }
  InternalStringInitialize();
  while ((CharP = *Pattern++) != '\0') {

    switch (CharP) {

    case '*':
      // Match zero or more chars
      while (*String != 0) {
        if (AsciiMetaiMatch(String, Pattern)) {
          return TRUE;
        }
        ++String;
      }
      return AsciiMetaiMatch(String, Pattern);

    case '?':
      // Match any one char
      if (*String == 0) {
        return FALSE;
      }
      ++String;
      break;

    case '[':
      // Match char set
      CharC = *String;
      if (CharC == 0) {
        // syntax problem
        return FALSE;
      }
      Index3  = 0;
      CharP   = *Pattern++;
      while (CharP != 0) {
        if (CharP == ']') {
          return FALSE;
        }
        if (CharP == '-') {
          // if range of chars, get high range
          CharP = *Pattern;
          if (CharP == 0 || CharP == ']') {
            // syntax problem
            return FALSE;
          }
          if ((TO_UPPER(CharC) >= TO_UPPER(Index3)) && (TO_UPPER(CharC) <= TO_UPPER(CharP))) {
            // if in range, it's a match
            break;
          }
        }
        Index3 = CharP;
        if (TO_UPPER(CharC) == TO_UPPER(CharP)) {
          // if char matches
          break;
        }
        CharP = *Pattern++;
      }
      // skip to end of match char set
      while ((CharP != 0) && (CharP != ']')) {
        CharP = *Pattern;
        ++Pattern;
      }
      ++String;
      break;

    default:
      CharC = *String;
      if (TO_UPPER(CharC) != TO_UPPER(CharP)) {
        return FALSE;
      }
      ++String;
      break;
    }
  }
  return (*String == 0);
}

// AsciiLwr
/// Converts all the characters in a string to lower case characters
/// @param Str A pointer to a string
VOID
EFIAPI
AsciiLwr (
  IN OUT CHAR8 *Str
) {
  if (Str == NULL) {
    return;
  }
  InternalStringInitialize();
  while (*Str != 0) {
    *Str = TO_LOWER(*Str);
    ++Str;
  }
}
// AsciiUpr
/// Converts all the characters in a string to upper case characters
/// @param Str A pointer to a string
VOID
EFIAPI
AsciiUpr (
  IN OUT CHAR8 *Str
) {
  if (Str == NULL) {
    return;
  }
  InternalStringInitialize();
  while (*Str != 0) {
    *Str = TO_UPPER(*Str);
    ++Str;
  }
}

// AsciiToLower
/// Duplicates all the characters in a string to lower case characters
/// @param Str A pointer to a string
/// @return A duplicate string with all lower case characters, which must be freed or NULL if there was an error
CHAR8 *
EFIAPI
AsciiToLower (
  IN CONST CHAR8 *Str
) {
  CHAR8 *Dup = AsciiStrDup(Str);
  if (Dup != NULL) {
    AsciiLwr(Dup);
  }
  return Dup;
}
// AsciiToUpper
/// Duplicates all the characters in a string to upper case characters
/// @param Str A pointer to a string
/// @return A duplicate string with all upper case characters, which must be freed or NULL if there was an error
CHAR8 *
EFIAPI
AsciiToUpper (
  IN CONST CHAR8 *Str
) {
  CHAR8 *Dup = AsciiStrDup(Str);
  if (Dup != NULL) {
    AsciiUpr(Dup);
  }
  return Dup;
}

// AsciiStrStr
/// Returns the first occurrence of a sub-string in a string
/// @param String       A pointer to a string
/// @param SearchString A pointer to a string for which to search
/// @return A pointer to the matched sub-string in String
/// @retval NULL If SearchString was not found in String
CHAR8 *
EFIAPI
AsciiStrStr (
  IN CHAR8 *String,
  IN CHAR8 *SearchString
) {
  // Check parameters
  if (String == NULL) {
    return NULL;
  }
  if ((SearchString == NULL) || (*SearchString == '\0')) {
    return String;
  }
  // Iterate through string for matches
  while (*String != '\0') {
    CHAR8 *SearchStringTmp = SearchString;
    CHAR8 *FirstMatch = String;

    // Check for match
    while ((*String == *SearchStringTmp) && (*String != '\0')) {
      ++String;
      ++SearchStringTmp;
    }

    if (*SearchStringTmp == '\0') {
      // Found
      return FirstMatch;
    }
    if (*String == '\0') {
      // Not found
      return NULL;
    }

    String = FirstMatch + 1;
  }
  // Not found
  return NULL;
}
// AsciiStriStr
/// Returns the first occurrence of a case-insensitive sub-string in a string
/// @param String       A pointer to a string
/// @param SearchString A pointer to a string for which to search
/// @return A pointer to the matched sub-string in String
/// @retval NULL If SearchString was not found in String
CHAR8 *
EFIAPI
AsciiStriStr (
  IN CHAR8 *String,
  IN CHAR8 *SearchString
) {
  // Check parameters
  if (String == NULL) {
    return NULL;
  }
  if ((SearchString == NULL) || (*SearchString == '\0')) {
    return String;
  }
  InternalStringInitialize();
  // Iterate through string for matches
  while (*String != '\0') {
    CHAR8 *SearchStringTmp = SearchString;
    CHAR8 *FirstMatch = String;

    // Check for match
    while ((TO_UPPER(*String) == TO_UPPER(*SearchStringTmp)) && (*String != '\0')) {
      ++String;
      ++SearchStringTmp;
    }

    if (*SearchStringTmp == '\0') {
      // Found
      return FirstMatch;
    }
    if (*String == '\0') {
      // Not found
      return NULL;
    }

    String = FirstMatch + 1;
  }
  // Not found
  return NULL;
}

// AsciiStrAppend
/// Append a character to a string
/// @param String    On input, the string to which to append or NULL to allocate a new string, on output, the possibly reallocated string, which needs freed
/// @param Count     On input, the length count, in characters, of the string, on output, the length count, in characters, of the string
/// @param Size      On input, the allocated size, in characters, of the string, on output, the allocated size, in characters, of the string
/// @param Character The character to append to the string
/// @return Whether the character was appended to the string or not
/// @retval EFI_INVALID_PARAMETER If String, *String, Count, or Size is NULL or Character is invalid
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated for the string
/// @retval EFI_SUCCESS           If the character was appended to the string successfully
EFI_STATUS
EFIAPI
AsciiStrAppend (
  IN OUT CHAR16 **String,
  IN OUT UINTN   *Count,
  IN OUT UINTN   *Size,
  IN     UINT32   Character
) {
  EFI_ENCODING_PROTOCOL *Encoding;
  // Get the UTF-8 encoding protocol
  Encoding = EfiUtf8Encoding();
  if (Encoding == NULL) {
    return EFI_UNSUPPORTED;
  }
  return EfiAppendCharacter(Encoding, (VOID **)String, Count, Size, Character);
}

// AsciiStrSplit
/// Split a string into a list
/// @param List    On output, the string list, which must be freed with AsciiStrListFree
/// @param Count   On output, the count of strings in the list
/// @param Str     The string to split
/// @param Split   The string that splits
/// @param Options The options for the string list
/// @return Whether the string was split or not
/// @retval EFI_INVALID_PARAMETER If List, Count, Str, or Split is NULL or *List is not NULL
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated for the string list
/// @retval EFI_NOT_FOUND         If the split string could not be found
/// @retval EFI_SUCCESS           If the string was split into a list successfully
EFI_STATUS
EFIAPI
AsciiStrSplit (
  OUT CHAR8 ***List,
  OUT UINTN   *Count,
  IN  CHAR8   *Str,
  IN  CHAR8   *Split,
  IN  UINTN    Options
) {
  CHAR8  *NextStr;
  CHAR8 **NewList;
  UINTN   NewCount;
  UINTN   Length;
  // Check parameters
  if ((List == NULL) || (*List != NULL) || (Count == NULL) || (Str == NULL) || (Split == NULL)) {
    return EFI_INVALID_PARAMETER;
  }
  Length = AsciiStrLen(Split);
  if (Length == 0) {
    return EFI_INVALID_PARAMETER;
  }
  if (Length > AsciiStrLen(Str)) {
    return EFI_NOT_FOUND;
  }
  // Start new string list
  NewList = NULL;
  NewCount = 0;
  // Iterate through the string
  do {
    // Get next instance of split string
    if (EFI_BITS_ANY_SET(Options, STR_SEARCH_CASE_INSENSITIVE)) {
      NextStr = AsciiStriStr(Str, Split);
    } else {
      NextStr = AsciiStrStr(Str, Split);
    }
    // Check if the split string was found
    if (NextStr == NULL) {
      if (NewCount == 0) {
        // No split string found
        return EFI_NOT_FOUND;
      }
      // Last string so done splitting
      AsciiStrList(&NewList, &NewCount, Str, 0, Options);
      break;
    }
    // Add string to list
    AsciiStrList(&NewList, &NewCount, Str, NextStr - Str, Options);
    // Advance string
    Str = NextStr + Length;
  // If we reach the null terminator then done splitting
  } while (*Str != '\0');

  // Return list and count
  *List = NewList;
  *Count = NewCount;
  return EFI_SUCCESS;
}

// AsciiStrList
/// Append a string to a list
/// @param List    The list to append the string, which must be freed with AsciiStrListFree, *List may be NULL to start new list
/// @param Count   The current count of strings in the list
/// @param Str     The string to append to the list
/// @param Length  The maximum length of the string or zero to use the entire string
/// @param Options The options for adding the strings
/// @return Whether the string was added to the list or not
/// @retval EFI_INVALID_PARAMETER If List, Count, or Str is NULL
/// @retval EFI_OUT_OF_RESOURCES  If the memory for the list could not be allocated
/// @retval EFI_ACCESS_DENIED     If STR_LIST_NO_DUPLICATES was used and the string already exists
/// @retval EFI_SUCCESS           If the string was added to the list successfully
EFI_STATUS
EFIAPI
AsciiStrList (
  IN OUT CHAR8 ***List,
  IN OUT UINTN   *Count,
  IN     CHAR8   *Str,
  IN     UINTN    Length,
  IN     UINTN    Options
) {
  CHAR8  *NewStr;
  CHAR8 **NewList;
  CHAR8 **InitialList;
  UINTN   InitialCount;
  UINTN   NewCount;
  UINTN   Index;

  // Check parameters
  if ((List == NULL) || (Count == NULL) || (Str == NULL)) {
    return EFI_INVALID_PARAMETER;
  }
  // Get the initial list and count
  InitialList = *List;
  InitialCount = (InitialList == NULL) ? 0 : *Count;
  // Check for duplicates if needed
  if (EFI_BITS_ANY_SET(Options, STR_LIST_NO_DUPLICATES)) {
    // Check case insensitively if needed
    if (EFI_BITS_ANY_SET(Options, STR_LIST_CASE_INSENSITIVE)) {
      // Check for duplicates case insensitively
      for (Index = 0; Index < InitialCount; ++Index) {
        if (AsciiStriCmp(InitialList[Index], Str) == 0) {
          // Already in list
          return EFI_ACCESS_DENIED;
        }
      }
    } else {
      // Check for duplicates
      for (Index = 0; Index < InitialCount; ++Index) {
        if (AsciiStrCmp(InitialList[Index], Str) == 0) {
          // Already in list
          return EFI_ACCESS_DENIED;
        }
      }
    }
  }
  // Duplicate the string
  NewStr = (Length == 0) ? AsciiStrDup(Str) : AsciiStrnDup(Str, Length);
  if (NewStr == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  // Reallocate size in the list for one more string
  NewCount = InitialCount + 1;
  NewList = EfiAllocateArray(CHAR8 *, NewCount);
  if (NewList == NULL) {
    EfiFreePool(NewStr);
    return EFI_OUT_OF_RESOURCES;
  }
  // Check if the string list is sorted
  if (EFI_BITS_ANY_SET(Options, STR_LIST_SORTED)) {
    // Determine insertion point with binary search
    UINTN Left = 0;
    UINTN Right = InitialCount;
    Index = 0;
    while (Left < Right) {
      Index = Left + ((Right - Left) >> 1);
      if (AsciiStriColl(InitialList[Index], NewStr) < 0) {
        Left = ++Index;
      } else {
        Right = Index;
      }
    }
    // Copy old list before insertion point
    if (Index > 0) {
      EfiCopyArray(CHAR8 *, NewList, InitialList, Index);
    }
    // Insert string into list
    NewList[Index] = NewStr;
    // Copy after insertion point
    if (Index < InitialCount) {
      EfiCopyArray(CHAR8 *, NewList + Index + 1, InitialList + Index, InitialCount - Index);
    }
  } else {
    // Copy old list
    EfiCopyArray(CHAR8 *, NewList, InitialList, InitialCount);
    EfiFreePool(InitialList);
    // Append string to list
    NewList[InitialCount] = NewStr;
  }
  // Set new list and count
  *List = NewList;
  *Count = NewCount;
  return EFI_SUCCESS;
}
// AsciiStrListFree
/// Free a string list
/// @param List  The string list to free
/// @param Count The count of strings in the list
/// @return Whether the string list was freed or not
/// @return EFI_INVALID_PARAMETER If List is NULL or Count is zero
/// @return EFI_SUCCESS           If the string list was freed successfully
EFI_STATUS
EFIAPI
AsciiStrListFree (
  IN CHAR8 **List,
  IN UINTN   Count
) {
  UINTN Index;
  // Check parameters
  if ((List == NULL) || (Count == 0)) {
    return EFI_INVALID_PARAMETER;
  }
  // Free each string
  for (Index = 0; Index < Count; ++Index) {
    EfiFreePool(List[Index]);
  }
  // Free the list
  EfiFreePool(List);
  return EFI_SUCCESS;
}

// AsciiStrToBoolean
/// Convert a string to boolean
/// @param Str     On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Boolean On output, the converted boolean value
/// @retval EFI_INVALID_PARAMETER If Str, *Str, or Boolean is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
AsciiStrToBoolean (
  IN OUT CONST CHAR8 **Str,
  OUT    BOOLEAN      *Boolean
) {
  return EfiEncodingToBoolean(EfiUtf8Encoding(), (VOID **)Str, NULL, Boolean);
}
// AsciiStrToUnsigned
/// Convert a string to unsigned
/// @param Str      On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Unsigned On output, the converted unsigned value
/// @param Base     The base of the integer (usually 10 for decimal)
/// @retval EFI_INVALID_PARAMETER If Str, *Str, or Unsigned is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
AsciiStrToUnsigned (
  IN OUT CONST CHAR8 **Str,
  OUT    UINT64       *Unsigned,
  IN     UINTN         Base
) {
  return EfiEncodingToUnsigned(EfiUtf8Encoding(), (VOID **)Str, NULL, Unsigned, Base);
}
// AsciiStrToInteger
/// Convert a string to integer
/// @param Str     On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Integer On output, the converted integer value
/// @param Base    The base of the integer (usually 10 for decimal)
/// @retval EFI_INVALID_PARAMETER If Str, *Str, or Integer is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
AsciiStrToInteger (
  IN OUT CONST CHAR8 **Str,
  OUT    INT64        *Integer,
  IN     UINTN         Base
) {
  return EfiEncodingToInteger(EfiUtf8Encoding(), (VOID **)Str, NULL, Integer, Base);
}
// AsciiStrToFloat
/// Convert a string to a floating point
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Float On output, the converted float value
/// @retval EFI_INVALID_PARAMETER If Float is NULL
/// @retval EFI_NOT_FOUND         The string did not contain any valid characters to convert
/// @retval EFI_SUCCESS           The string was converted and the string pointer was updated to point after any characters used in converting
EFI_STATUS
EFIAPI
AsciiStrToFloat (
  IN OUT CONST CHAR8 **Str,
  OUT    FLOAT64      *Float
) {
  return EfiEncodingToFloat(EfiUtf8Encoding(), (VOID **)Str, NULL, Float);
}
// AsciiStrToDateTime
/// Convert a date and/or time formatted character string buffer to a date and time
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param DateTime On output, the converted date and time
/// @retval EFI_INVALID_PARAMETER  If This, Encoding, Buffer, *Buffer, or DateTime is NULL
/// @retval EFI_NOT_FOUND          If the buffer is not valid for conversion
/// @retval EFI_SUCCESS            If the buffer was converted to a floating point successfully
EFI_STATUS
EFIAPI
AsciiStrToDateTime (
  IN OUT CONST CHAR16 **Str,
  IN OUT EFI_TIME      *DateTime
) {
  return EfiEncodingToDateTime(EfiUtf8Encoding(), (VOID **)Str, NULL, DateTime);
}
// AsciiStrToGuid
/// Convert a GUID formatted character string buffer to a GUID
/// @param Str   On input, the address of the position in the string to start converting, on output, the address of the new position in the string after converting
/// @param Guid  On output, the converted GUID
/// @retval EFI_INVALID_PARAMETER  If This, Encoding, Buffer, *Buffer, or Guid is NULL
/// @retval EFI_NOT_FOUND          If the buffer is not valid for conversion
/// @retval EFI_SUCCESS            If the buffer was converted to a GUID successfully
EFI_STATUS
EFIAPI
AsciiStrToGuid (
  IN OUT CONST CHAR16 **Str,
  IN OUT EFI_GUID      *Guid
) {
  return EfiEncodingToGuid(EfiUtf8Encoding(), (VOID **)Str, NULL, Guid);
}
