///
/// @file Library/Serialize/XmlStates.c
///
/// GUI XML implementation states
///

#include "XmlStates.h"

// XML_SIGNATURE_ATTRIBUTE
/// Valid XML document attributes
typedef struct XML_SIGNATURE_ATTRIBUTE XML_SIGNATURE_ATTRIBUTE;
struct XML_SIGNATURE_ATTRIBUTE {

  // Name
  /// The name of the document attribute
  CONST CHAR16  *Name;
  // Count
  /// The count of allowed values
  UINTN          Count;
  // Values
  /// The valid values of the document attribute
  CONST CHAR16 **Values;

};

// mXmlSignatureVersionValues
/// The allowed values for the version signature attribute
STATIC CONST CHAR16 *mXmlSignatureVersionValues[] = {
  // XML version 1.0, only allowed value currently
  L"1.0"
};
// mXmlSignatureEncodingValues
/// The allowed values for the encoding signature attribute
STATIC CONST CHAR16 *mXmlSignatureEncodingValues[] = {
  L"",
  NULL
};
// mXmlSignatureStandaloneValues
/// The allowed values for the standalone signature attribute
STATIC CONST CHAR16 *mXmlSignatureStandaloneValues[] = {
  // Standalone document
  L"yes",
  // External dependencies
  L"no",
  // Standalone document by presence (no value)
  L""
};
// mXmlSignatureAttributes
/// The allowed XML document attributes
STATIC XML_SIGNATURE_ATTRIBUTE mXmlSignatureAttributes[] = {
  { L"version", ARRAY_COUNT(mXmlSignatureVersionValues), mXmlSignatureVersionValues },
  { L"encoding", ARRAY_COUNT(mXmlSignatureEncodingValues), mXmlSignatureEncodingValues },
  { L"standalone", ARRAY_COUNT(mXmlSignatureStandaloneValues), mXmlSignatureStandaloneValues }
};

// mXmlSignatureRules
/// XML_LANG_STATE_SIGNATURE state rules
DECL_LANG_RULES(mXmlSignatureRules)
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE | LANG_RULE_SKIP, XML_LANG_STATE_SIGNATURE_ATTRIBUTE, L"<?xml" ),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_TAG, L"<!"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlSignatureAttributeRules
/// XML_LANG_STATE_SIGNATURE_ATTRIBUTE state rules
DECL_LANG_RULES(mXmlSignatureAttributeRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG, L"?>"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP, XML_LANG_STATE_SIGNATURE_ATTRIBUTE_VALUE, L"="),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_QUOTE, L"\'"),
END_LANG_RULES();
// mXmlSignatureAttributeValueRules
/// XML_LANG_STATE_SIGNATURE_ATTRIBUTE_VALUE state rules
DECL_LANG_RULES(mXmlSignatureAttributeValueRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG, L"?>"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_SIGNATURE_ATTRIBUTE, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_SIGNATURE_ATTRIBUTE, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_SIGNATURE_ATTRIBUTE, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_SIGNATURE_ATTRIBUTE, L"\n"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_QUOTE, L"\'"),
END_LANG_RULES();
// mXmlTagRules
/// XML_LANG_STATE_TAG state rules
DECL_LANG_RULES(mXmlTagRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_TAG_NAME, L"<"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_TAG_CLOSE, L"</"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_TAG, L"<!"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_PUSH, XML_LANG_STATE_TAG_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_PUSH, XML_LANG_STATE_TAG_QUOTE, L"\'"),
END_LANG_RULES();
// mXmlTagNameRules
/// XML_LANG_STATE_TAG_NAME state rules
DECL_LANG_RULES(mXmlTagNameRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_POP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L"/>"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\n"),
END_LANG_RULES();
// mXmlTagAttributeRules
/// XML_LANG_STATE_TAG_ATTRIBUTE state rules
DECL_LANG_RULES(mXmlTagAttributeRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L"/>"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP, XML_LANG_STATE_TAG_ATTRIBUTE_VALUE, L"="),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_QUOTE, L"\'"),
END_LANG_RULES();
// mXmlAttributeValueRules
/// XML_LANG_STATE_TAG_ATTRIBUTE_VALUE state rules
DECL_LANG_RULES(mXmlTagAttributeValueRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L"/>"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, XML_LANG_STATE_TAG_ATTRIBUTE, L"\n"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_QUOTE, L"\'"),
END_LANG_RULES();
// mXmlTagCloseRules
/// XML_LANG_STATE_TAG_CLOSE state rules
DECL_LANG_RULES(mXmlTagCloseRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlTagEndRules
/// XML_LANG_STATE_TAG_END state rules
DECL_LANG_RULES(mXmlTagEndRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlTagQuoteRules
/// XML_LANG_STATE_TAG_QUOTE state rules
DECL_LANG_RULES(mXmlTagQuoteRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP_BEFORE, LANG_STATE_PREVIOUS, L"\'"),
END_LANG_RULES();
// mXmlTagDoubleQuoteRules
/// XML_LANG_STATE_TAG_DOUBLE_QUOTE state rules
DECL_LANG_RULES(mXmlTagDoubleQuoteRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP_BEFORE, LANG_STATE_PREVIOUS, L"\""),
END_LANG_RULES();
// mXmlQuoteRules
/// XML_LANG_STATE_QUOTE state rules
DECL_LANG_RULES(mXmlQuoteRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP_BEFORE, LANG_STATE_PREVIOUS, L"\'"),
END_LANG_RULES();
// mXmlDoubleQuoteRules
/// XML_LANG_STATE_DOUBLE_QUOTE state rules
DECL_LANG_RULES(mXmlDoubleQuoteRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP_BEFORE, LANG_STATE_PREVIOUS, L"\""),
END_LANG_RULES();
// mXmlEntityRules
/// XML_LANG_STATE_ENTITY state rules
DECL_LANG_RULES(mXmlEntityRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP | LANG_RULE_POP_SAFE, LANG_STATE_PREVIOUS, L";"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP | LANG_RULE_POP_SAFE, LANG_STATE_PREVIOUS, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP | LANG_RULE_POP_SAFE, LANG_STATE_PREVIOUS, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP | LANG_RULE_POP_SAFE, LANG_STATE_PREVIOUS, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP | LANG_RULE_POP_SAFE, LANG_STATE_PREVIOUS, L"\n"),
END_LANG_RULES();
// mXmlCommentRules
/// XML_LANG_STATE_COMMENT state rules
DECL_LANG_RULES(mXmlCommentRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L"--"),
END_LANG_RULES();
// mXmlDocumentTagRules
/// XML_LANG_STATE_DOCUMENT_TAG state rules
DECL_LANG_RULES(mXmlDocumentTagRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE | LANG_RULE_SKIP, XML_LANG_STATE_DOCUMENT_NAME, L"DOCTYPE"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE | LANG_RULE_SKIP, XML_LANG_STATE_DOCUMENT_ENTITY, L"ENTITY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE | LANG_RULE_SKIP, XML_LANG_STATE_DOCUMENT_ELEMENT, L"ELEMENT"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE | LANG_RULE_SKIP, XML_LANG_STATE_DOCUMENT_ATTLIST, L"ATTLIST"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
END_LANG_RULES();
// mXmlDocumentNameRules
/// XML_LANG_STATE_DOCUMENT_NAME state rules
DECL_LANG_RULES(mXmlDocumentNameRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentTypeRules
/// XML_LANG_STATE_DOCUMENT_TYPE state rules
DECL_LANG_RULES(mXmlDocumentTypeRules)
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_PUBLIC, L"PUBLIC"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_SYSTEM, L"SYSTEM"),
  DECL_LANG_RULE_PUSH(LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_INTERNAL, XML_LANG_STATE_TAG_END, L"["),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentPublicRules
/// XML_LANG_STATE_DOCUMENT_PUBLIC state rules
DECL_LANG_RULES(mXmlDocumentPublicRules)
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, XML_LANG_STATE_DOCUMENT_PUBLIC_IDENTIFIER, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentPublicIdentifierRules
/// XML_LANG_STATE_DOCUMENT_PUBLIC_IDENTIFIER state rules
DECL_LANG_RULES(mXmlDocumentPublicIdentifierRules)
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, XML_LANG_STATE_DOCUMENT_PUBLIC_LOCATION, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentPublicLocationRules
/// XML_LANG_STATE_DOCUMENT_PUBLIC_LOCATION state rules
DECL_LANG_RULES(mXmlDocumentPublicLocationRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentSystemRules
/// XML_LANG_STATE_DOCUMENT_SYSTEM state rules
DECL_LANG_RULES(mXmlDocumentSystemRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_INTERNAL, XML_LANG_STATE_TAG_END, L"["),
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, XML_LANG_STATE_DOCUMENT_SYSTEM_LOCATION, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentSystemLocationRules
/// XML_LANG_STATE_DOCUMENT_SYSTEM_LOCATION state rules
DECL_LANG_RULES(mXmlDocumentSystemLocationRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_INTERNAL, XML_LANG_STATE_TAG_END, L"["),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentInternalRules
/// XML_LANG_STATE_DOCUMENT_INTERNAL state rules
DECL_LANG_RULES(mXmlDocumentInternalRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L"]"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_TAG, L"<!"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentEntityRules
/// XML_LANG_STATE_DOCUMENT_ENTITY state rules
DECL_LANG_RULES(mXmlDocumentEntityRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP, XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentEntityParameterRules
/// XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER state rules
DECL_LANG_RULES(mXmlDocumentEntityParameterRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentEntityValueRules
/// XML_LANG_STATE_DOCUMENT_ENTITY_VALUE state rules
DECL_LANG_RULES(mXmlDocumentEntityValueRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ENTITY_PUBLIC, L"PUBLIC"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ENTITY_SYSTEM, L"SYSTEM"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentEntityPublicRules
/// XML_LANG_STATE_DOCUMENT_ENTITY_PUBLIC state rules
DECL_LANG_RULES(mXmlDocumentEntityPublicRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentEntitySystemRules
/// XML_LANG_STATE_DOCUMENT_ENTITY_SYSTEM state rules
DECL_LANG_RULES(mXmlDocumentEntitySystemRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentElementRules
/// XML_LANG_STATE_DOCUMENT_ELEMENT state rules
DECL_LANG_RULES(mXmlDocumentElementRules)
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS, XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN, L"("),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentElementRules
/// XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS state rules
DECL_LANG_RULES(mXmlDocumentElementAliasRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_CURRENT, L")"),
  DECL_LANG_RULE(LANG_RULE_TOKEN, LANG_STATE_CURRENT, L"|"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentElementOpenRules
/// XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN state rules
DECL_LANG_RULES(mXmlDocumentElementOpenRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE, L"-"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE, L"O"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT, L"("),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_TAG_END, L"ANY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_TAG_END, L"EMPTY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_TAG_END, L"#PCDATA"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentElementCloseRules
/// XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE state rules
DECL_LANG_RULES(mXmlDocumentElementCloseRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT, L"-"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT, L"O"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentElementContentRules
/// XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT state rules
DECL_LANG_RULES(mXmlDocumentElementContentRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"("),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"ANY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"EMPTY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"#PCDATA"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L")"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L","),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"|"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"?"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"*"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"+"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST state rules
DECL_LANG_RULES(mXmlDocumentAttributeListRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE_PUSH(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS, XML_LANG_STATE_DOCUMENT_ATTLIST_NAME, L"("),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListNameRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST_NAME state rules
DECL_LANG_RULES(mXmlDocumentAttributeListNameRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListTypeRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST_TYPE state rules
DECL_LANG_RULES(mXmlDocumentAttributeListTypeRules)
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"("),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"ID"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"CDATA"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"IDREF"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"IDREFS"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"ENTITY"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"NMTOKEN"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"ENTITIES"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"NMTOKENS"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"NOTATION"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_SKIP, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListEnumerationRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION state rules
DECL_LANG_RULES(mXmlDocumentAttributeListEnumerationRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"|"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListPresenceRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE state rules
DECL_LANG_RULES(mXmlDocumentAttributeListPresenceRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"#FIXED"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"#IMPLIED"),
  DECL_LANG_RULE(LANG_RULE_INSENSITIVE, LANG_STATE_CURRENT, L"#REQUIRED"),
  DECL_LANG_RULE(LANG_RULE_SKIP | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();
// mXmlDocumentAttributeListDefaultRules
/// XML_LANG_STATE_DOCUMENT_ATTLIST_DEFAULT state rules
DECL_LANG_RULES(mXmlDocumentAttributeListDefaultRules)
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_POP, LANG_STATE_PREVIOUS, L">"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"&"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_ENTITY, L"%"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_DOUBLE_QUOTE, L"\""),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN | LANG_RULE_PUSH, XML_LANG_STATE_COMMENT, L"--"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L" "),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\t"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\r"),
  DECL_LANG_RULE(LANG_RULE_TOKEN | LANG_RULE_SKIP | LANG_RULE_SKIP_EMPTY_TOKEN, LANG_STATE_CURRENT, L"\n"),
END_LANG_RULES();

// mXmlStates
/// Static XML states
DECL_LANG_STATES(mXmlStates)
  // XML_LANG_STATE_SIGNATURE
  DECL_LANG_STATE(XML_LANG_STATE_SIGNATURE, mXmlSignatureRules),
  // XML_LANG_STATE_ATTRIBUTE
  DECL_LANG_STATE(XML_LANG_STATE_SIGNATURE_ATTRIBUTE, mXmlSignatureAttributeRules),
  // XML_LANG_STATE_ATTRIBUTE_VALUE
  DECL_LANG_STATE(XML_LANG_STATE_SIGNATURE_ATTRIBUTE_VALUE, mXmlSignatureAttributeValueRules),
  // XML_LANG_STATE_TAG
  DECL_LANG_STATE(XML_LANG_STATE_TAG, mXmlTagRules),
  // XML_LANG_STATE_TAG_NAME
  DECL_LANG_STATE(XML_LANG_STATE_TAG_NAME, mXmlTagNameRules),
  // XML_LANG_STATE_ATTRIBUTE
  DECL_LANG_STATE(XML_LANG_STATE_TAG_ATTRIBUTE, mXmlTagAttributeRules),
  // XML_LANG_STATE_ATTRIBUTE_VALUE
  DECL_LANG_STATE(XML_LANG_STATE_TAG_ATTRIBUTE_VALUE, mXmlTagAttributeValueRules),
  // XML_LANG_STATE_TAG_CLOSE
  DECL_LANG_STATE(XML_LANG_STATE_TAG_CLOSE, mXmlTagCloseRules),
  // XML_LANG_STATE_TAG_END
  DECL_LANG_STATE(XML_LANG_STATE_TAG_END, mXmlTagEndRules),
  // XML_LANG_STATE_TAG_QUOTE
  DECL_LANG_STATE(XML_LANG_STATE_TAG_QUOTE, mXmlTagQuoteRules),
  // XML_LANG_STATE_TAG_DOUBLE_QUOTE
  DECL_LANG_STATE(XML_LANG_STATE_TAG_DOUBLE_QUOTE, mXmlTagDoubleQuoteRules),
  // XML_LANG_STATE_QUOTE
  DECL_LANG_STATE(XML_LANG_STATE_QUOTE, mXmlQuoteRules),
  // XML_LANG_STATE_DOUBLE_QUOTE
  DECL_LANG_STATE(XML_LANG_STATE_DOUBLE_QUOTE, mXmlDoubleQuoteRules),
  // XML_LANG_STATE_ENTITY
  DECL_LANG_STATE(XML_LANG_STATE_ENTITY, mXmlEntityRules),
  // XML_LANG_STATE_COMMENT
  DECL_LANG_STATE(XML_LANG_STATE_COMMENT, mXmlCommentRules),
  // XML_LANG_STATE_DOCUMENT_TAG
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_TAG, mXmlDocumentTagRules),
  // XML_LANG_STATE_DOCUMENT_NAME
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_NAME, mXmlDocumentNameRules),
  // XML_LANG_STATE_DOCUMENT_TYPE
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_TYPE, mXmlDocumentTypeRules),
  // XML_LANG_STATE_DOCUMENT_PUBLIC
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_PUBLIC, mXmlDocumentPublicRules),
  // XML_LANG_STATE_DOCUMENT_PUBLIC_IDENTIFIER
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_PUBLIC_IDENTIFIER, mXmlDocumentPublicIdentifierRules),
  // XML_LANG_STATE_DOCUMENT_PUBLIC_LOCATION
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_PUBLIC_LOCATION, mXmlDocumentPublicLocationRules),
  // XML_LANG_STATE_DOCUMENT_TYPE_SYSTEM
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_SYSTEM, mXmlDocumentSystemRules),
  // XML_LANG_STATE_DOCUMENT_SYSTEM_LOCATION
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_SYSTEM_LOCATION, mXmlDocumentSystemLocationRules),
  // XML_LANG_STATE_DOCUMENT_TYPE_INTERNAL
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_INTERNAL, mXmlDocumentInternalRules),
  // XML_LANG_STATE_DOCUMENT_ENTITY
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ENTITY, mXmlDocumentEntityRules),
  // XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER, mXmlDocumentEntityParameterRules),
  // XML_LANG_STATE_DOCUMENT_ENTITY_VALUE
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ENTITY_VALUE, mXmlDocumentEntityValueRules),
  // XML_LANG_STATE_DOCUMENT_ENTITY_PUBLIC
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ENTITY_PUBLIC, mXmlDocumentEntityPublicRules),
  // XML_LANG_STATE_DOCUMENT_ENTITY_SYSTEM
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ENTITY_SYSTEM, mXmlDocumentEntitySystemRules),
  // XML_LANG_STATE_DOCUMENT_ELEMENT
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ELEMENT, mXmlDocumentElementRules),
  // XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS, mXmlDocumentElementAliasRules),
  // XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN, mXmlDocumentElementOpenRules),
  // XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE, mXmlDocumentElementCloseRules),
  // XML_LANG_STATE_DOCUMENT_ELEMENT_CHILDREN
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT, mXmlDocumentElementContentRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST, mXmlDocumentAttributeListRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST_NAME
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST_NAME, mXmlDocumentAttributeListNameRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST_TYPE
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST_TYPE, mXmlDocumentAttributeListTypeRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION, mXmlDocumentAttributeListEnumerationRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE, mXmlDocumentAttributeListPresenceRules),
  // XML_LANG_STATE_DOCUMENT_ATTLIST_DEFAULT
  DECL_LANG_STATE(XML_LANG_STATE_DOCUMENT_ATTLIST_DEFAULT, mXmlDocumentAttributeListDefaultRules),
END_LANG_STATES();

// XML_PREDEFINED_NAME
/// Predefined name and value pair
typedef struct XML_PREDEFINED_NAME XML_PREDEFINED_NAME;
struct XML_PREDEFINED_NAME {

  // Name
  /// The name
  CHAR16 *Name;
  // Value
  /// The value
  CHAR16 *Value;

};
// mXmlPredefinedEntities
/// Predefined entities
STATIC XML_PREDEFINED_NAME mXmlPredefinedEntities[] = {
  // Ampersand
  { L"amp",  L"&" },
  // Apostrophe/single quote
  { L"apos", L"\'" },
  // Greater than/right angle bracket
  { L"gt",   L">" },
  // Less than/left angle bracket
  { L"lt",   L"<" },
  // Non breaking space
  { L"nbsp", L" " },
  // Double quote
  { L"quot", L"\"" },
};

// XmlTreeCreate
/// Create XML document tree node
/// @param Tree On output, the created tree node, which needs freed with XmlTreeFree
/// @param Name The name of the tree node
/// @return Whether the XML document tree node was created or not
/// @retval EFI_INVALID_PARAMETER If Tree or Name is NULL
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated
/// @retval EFI_SUCCESS           If the XML document tree node was created successfully
STATIC
EFI_STATUS
EFIAPI
XmlTreeCreate (
  OUT XML_TREE **Tree,
  IN  CHAR16    *Name
) {
  XML_TREE *Ptr;
  // Check parameters
  if ((Tree == NULL) || (Name == NULL) || (*Name == '\0')) {
    return EFI_INVALID_PARAMETER;
  }
  // Allocate tree node
  Ptr = EfiAllocateByType(XML_TREE);
  if (Ptr == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  // Set name
  Ptr->Name = StrDup(Name);
  if (Ptr->Name == NULL) {
    EfiFreePool(Ptr);
    return EFI_OUT_OF_RESOURCES;
  }
  // Set other members to NULL
  Ptr->Next = NULL;
  Ptr->Value = NULL;
  Ptr->Children = NULL;
  Ptr->Attributes = NULL;
  // Return created tree node
  *Tree = Ptr;
  return EFI_SUCCESS;
}
// XmlAttributeCreate
/// Create XML document tree node attribute
/// @param Attribute On output, the created tree node attribute, which needs freed with XmlAttributeFree
/// @param Name      The name of the tree node attribute
/// @return Whether the XML document tree node attribute was created or not
/// @retval EFI_INVALID_PARAMETER If Attribute or Name is NULL
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated
/// @retval EFI_SUCCESS           If the XML document tree node attribute was created successfully
STATIC
EFI_STATUS
EFIAPI
XmlAttributeCreate (
  OUT XML_LIST **Attribute,
  IN  CHAR16    *Name
) {
  XML_LIST *Ptr;
  // Check parameters
  if ((Attribute == NULL) || (Name == NULL) || (*Name == '\0')) {
    return EFI_INVALID_PARAMETER;
  }
  // Allocate tree node attribute
  Ptr = EfiAllocateByType(XML_LIST);
  if (Ptr == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  // Set name
  Ptr->Attribute.Name = StrDup(Name);
  if (Ptr->Attribute.Name == NULL) {
    EfiFreePool(Ptr);
    return EFI_OUT_OF_RESOURCES;
  }
  // Set other members to NULL
  Ptr->Attribute.Value = NULL;
  Ptr->Next = NULL;
  // Return created tree node attribute
  *Attribute = Ptr;
  return EFI_SUCCESS;
}
// XmlAttributeFree
/// Free XML document tree node attribute
/// @param Attribute The tree node attribute to free
/// @return Whether the XML document tree node attribute was freed or not
/// @retval EFI_INVALID_PARAMETER If Attribute is NULL
/// @retval EFI_SUCCESS           If the XML document tree node attribute was freed successfully
STATIC
EFI_STATUS
EFIAPI
XmlAttributeFree (
  IN XML_LIST *Attribute
) {
  // Check parameters
  if (Attribute == NULL) {
    return EFI_INVALID_PARAMETER;
  }
  if (Attribute->Attribute.Name != NULL) {
    EfiFreePool(Attribute->Attribute.Name);
    Attribute->Attribute.Name = NULL;
  }
  if (Attribute->Attribute.Value != NULL) {
    EfiFreePool(Attribute->Attribute.Value);
    Attribute->Attribute.Value = NULL;
  }
  EfiFreePool(Attribute);
  return EFI_SUCCESS;
}
// XmlTreeFree
/// Free XML document tree node
/// @param Tree The tree node to free
/// @return Whether the XML document tree node was freed or not
/// @retval EFI_INVALID_PARAMETER If Tree is NULL
/// @retval EFI_SUCCESS           If the XML document tree node was freed successfully
STATIC
EFI_STATUS
EFIAPI
XmlTreeFree (
  IN XML_TREE *Tree
) {
  // Check parameters
  if (Tree == NULL) {
    return EFI_INVALID_PARAMETER;
  }
  if (Tree->Name != NULL) {
    EfiFreePool(Tree->Name);
    Tree->Name = NULL;
  }
  if (Tree->Value != NULL) {
    EfiFreePool(Tree->Value);
    Tree->Value = NULL;
  }
  while (Tree->Attributes != NULL) {
    XML_LIST *Attribute = Tree->Attributes;
    Tree->Attributes = Attribute->Next;
    XmlAttributeFree(Attribute);
  }
  while (Tree->Children != NULL) {
    XML_TREE *Child = Tree->Children;
    Tree->Children = Child->Next;
    XmlTreeFree(Child);
  }
  EfiFreePool(Tree);
  return EFI_SUCCESS;
}

// XmlCallback
/// XML token parsed callback
/// @param Parser  The language parser
/// @param StateId The current language parser state identifier
/// @param Token   The parsed token
/// @param Context The user context passed when callback was registered
/// @return Whether the token was valid or not
STATIC
EFI_STATUS
EFIAPI
XmlCallback (
  IN OUT LANG_PARSER *Parser,
  IN     UINTN        StateId,
  IN     CHAR16      *Token,
  IN     VOID        *Context
) {
  EFI_STATUS  Status = EFI_SUCCESS;
  XML_STACK  *Stack;
  XML_LIST   *List;
  XML_TREE   *Tree;
  XML_PARSER *XmlParser = (XML_PARSER *)Context;
  CHAR16     *Value;
  UINTN       PreviousId = LANG_STATE_PREVIOUS;
  UINTN       TokenLength;
  UINTN       PreviousOptions;
  UINTN       Index;
  // Check parameters
  if (XmlParser == NULL) {
    return EFI_INVALID_PARAMETER;
  }
  if (Token == NULL) {
    return EFI_SUCCESS;
  }
  TokenLength = StrLen(Token);
  if (TokenLength == 0) {
    return EFI_SUCCESS;
  }
  XML_LOG(L"XML token: `%s`\n", Token);
  switch (StateId) {
    case XML_LANG_STATE_SIGNATURE_ATTRIBUTE:
      // Signature tag attribute
      Value = Token;
      // Check token is valid attribute name
      if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
        ParseError(Parser, L"Invalid attribute name `%s`", Token);
        return EFI_NOT_FOUND;
      } else {
        // Check token is valid document attribute
        Index = 0;
        while (Index < ARRAY_COUNT(mXmlSignatureAttributes)) {
          // Check if the attribute name matches
          XML_SIGNATURE_ATTRIBUTE *Attribute = mXmlSignatureAttributes + Index;
          if ((Attribute->Name != NULL) && (StriCmp(Attribute->Name, Token) == 0)) {
            break;
          }
          ++Index;
        }
        // Check a valid attribute was found
        if (Index >= ARRAY_COUNT(mXmlSignatureAttributes)) {
          ParseWarn(Parser, L"Invalid XML signature attribute `%s`", Token);
        }
      }
      // Check document root tree exists
      if ((XmlParser->Document->Tree != NULL) || (XmlParser->Stack != NULL)) {
        // No document element
        Status = EFI_NOT_READY;
        break;
      }
      // Create attribute
      List = NULL;
      Status = XmlAttributeCreate(&List, Token);
      if (EFI_ERROR(Status)) {
        return Status;
      }
      // Add attribute to document
      if (XmlParser->Document->Attributes == NULL) {
        XmlParser->Document->Attributes = List;
      } else {
        XML_LIST *Attr = XmlParser->Document->Attributes;
        while (Attr->Next != NULL) {
          Attr = Attr->Next;
        }
        Attr->Next = List;
      }
      break;

    case XML_LANG_STATE_SIGNATURE_ATTRIBUTE_VALUE:
      // Signature tag attribute value
      if ((XmlParser->Document->Tree != NULL) || (XmlParser->Document->Attributes == NULL)) {
        // No attribute to give value
        Status = EFI_NOT_READY;
        break;
      }
      // Find the current document attribute
      List = XmlParser->Document->Attributes;
      while (List->Next != NULL) {
        List = List->Next;
      }
      // Check to make sure there's not somehow already a value
      if (List->Attribute.Value != NULL) {
        // Unexpected value for attribute?
        Status = EFI_NOT_FOUND;
        break;
      }
      // Check allowed signature attributes
      for (Index = 0; Index < ARRAY_COUNT(mXmlSignatureAttributes); ++Index) {
        XML_SIGNATURE_ATTRIBUTE *Attribute = mXmlSignatureAttributes + Index;
        if ((Attribute->Name != NULL) && (StriCmp(Attribute->Name, List->Attribute.Name) == 0)) {
          // Check if token matches allowed values
          Index = 0;
          while (Index < Attribute->Count) {
            if ((Attribute->Values[Index] == NULL) ||
                (StriCmp(Attribute->Values[Index], Token) == 0)) {
              break;
            }
            ++Index;
          }
          // Check allowed values
          if (Index >= Attribute->Count) {
            ParseWarn(Parser, L"Invalid value `%s` for XML signature attribute `%s`", Token, List->Attribute.Name);
          }
          break;
        }
      }
      // Set the attribute value
      List->Attribute.Value = StrDup(Token);
      break;

    case XML_LANG_STATE_TAG:
      // Tag contents/value
      Stack = XmlParser->Stack;
      // Check if this is whitespace to insert a single space instead of all continuous whitespace
      if (EFI_BITS_ARE_UNSET(XmlParser->Options, XML_OPTION_DISABLE_WHITESPACE_TRIMMING) &&
          ((StrCmp(Token, L" ") == 0) || (StrCmp(Token, L"\t") == 0) ||
           (StrCmp(Token, L"\r") == 0) || (StrCmp(Token, L"\n") == 0))) {
        // Check if there is a value yet otherwise skip whitespace
        if ((Stack != NULL) && (Stack->Tree != NULL) && (Stack->Tree->Value != NULL)) {
          // Determine whether the last character of the current token is a space
          Value = Stack->Tree->Value;
          if (*Value != '\0') {
            while (*(++Value) != '\0');
            if (*(--Value) != ' ') {
              // Append a space instead of any other whitespace
              Token = L" ";
            } else {
              // The current token already ends with a space so skip this whitespace
              Token = NULL;
            }
          } else {
            // Empty token so skip this whitespace
            Token = NULL;
          }
        } else {
          // No token yet so skip this whitespace
          Token = NULL;
        }
      }
      // Check that the token is still valid
      if (Token != NULL) {
        // Check there is a current tree tag
        if ((Stack == NULL) || (Stack->Tree == NULL)) {
          // No element to have a value
          Status = EFI_NOT_FOUND;
          break;
        }
        if (Stack->Tree->Value != NULL) {
          // Append the current token to the current value
          Value = EfiPoolPrint(L"%s%s", Stack->Tree->Value, Token);
          if (Stack->Tree->Value == NULL) {
            return EFI_OUT_OF_RESOURCES;
          }
          // Free the old value and set the new value
          EfiFreePool(Stack->Tree->Value);
          Stack->Tree->Value = Value;
        } else {
          // Start a new value if not whitespace
          Stack->Tree->Value = StrDup(Token);
          if (Stack->Tree->Value == NULL) {
            return EFI_OUT_OF_RESOURCES;
          }
        }
      }
      break;

    case XML_LANG_STATE_TAG_NAME:
      // Tag name
      Stack = XmlParser->Stack;
      // Check if this is an immediate close tag
      if (StrCmp(Token, L"/>") == 0) {
        if ((Stack == NULL) || (Stack->Tree == NULL) || (Stack->Tree->Name == NULL)) {
          // No element to close
          Status = EFI_NOT_READY;
          break;
        }
        // Pop the top open tag from the stack
        Stack = XmlParser->Stack;
        XmlParser->Stack = Stack->Previous;
        EfiFreePool(Stack);
        break;
      }
      // Check token is valid tag name
      Value = Token;
      if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
        ParseError(Parser, L"Invalid name `%s`", Token);
        return EFI_NOT_FOUND;
      }
      // Check if there is already a stack with an invalid tree or there is already a root element that was closed
      if (((Stack == NULL) && (XmlParser->Document->Tree != NULL)) ||
          ((Stack != NULL) && (Stack->Tree == NULL))) {
        Status = EFI_NOT_READY;
        break;
      }
      // Allocate a new stack object
      Stack = EfiAllocateByType(XML_STACK);
      if (Stack == NULL) {
        return EFI_OUT_OF_RESOURCES;
      }
      // Create new tree node with token as tag name
      Tree = NULL;
      Status = XmlTreeCreate(&Tree, Token);
      if (!EFI_ERROR(Status) && (Tree == NULL)) {
        Status = EFI_OUT_OF_RESOURCES;
      }
      if (EFI_ERROR(Status)) {
        EfiFreePool(Stack);
        return Status;
      }
      // Check if there is already a document root node
      if (XmlParser->Document->Tree == NULL) {
        // Set the document root node
        XmlParser->Document->Tree = Tree;
      } else if (XmlParser->Stack->Tree->Children == NULL) {
        // Set tree as first child
        XmlParser->Stack->Tree->Children = Tree;
      } else {
        // Add to end of children
        XML_TREE *Child = XmlParser->Stack->Tree->Children;
        while (Child->Next != NULL) {
          Child = Child->Next;
        }
        Child->Next = Tree;
      }
      // Set the stack object
      Stack->Previous = XmlParser->Stack;
      Stack->Tree = Tree;
      XmlParser->Stack = Stack;
      break;

    case XML_LANG_STATE_TAG_ATTRIBUTE:
      // Check if this is an immdiate close tag
      if (StrCmp(Token, L"/>") == 0) {
        if (XmlParser->Stack == NULL) {
          // No element to close
          Status =  EFI_NOT_READY;
          break;
        }
        // Pop the top open tag from the stack
        Stack = XmlParser->Stack;
        XmlParser->Stack = Stack->Previous;
        EfiFreePool(Stack);
        break;
      }
      // Check token is valid attribute name
      Value = Token;
      if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
        ParseError(Parser, L"Invalid attribute name `%s`", Token);
        return EFI_NOT_FOUND;
      }
      // New tag attribute
      Stack = XmlParser->Stack;
      if ((Stack == NULL) || (Stack->Tree == NULL)) {
        // No node to add attribute
        Status = EFI_NOT_READY;
        break;
      }
      // Create attribute
      List = NULL;
      Status = XmlAttributeCreate(&List, Token);
      if (EFI_ERROR(Status)) {
        return Status;
      }
      // Add attribute to tree node
      if (Stack->Tree->Attributes == NULL) {
        Stack->Tree->Attributes = List;
      } else {
        XML_LIST *Attr = Stack->Tree->Attributes;
        while (Attr->Next != NULL) {
          Attr = Attr->Next;
        }
        Attr->Next = List;
      }
      break;

    case XML_LANG_STATE_TAG_ATTRIBUTE_VALUE:
      // Check if this is an immdiate close tag
      if (StrCmp(Token, L"/>") == 0) {
        if (XmlParser->Stack == NULL) {
          // No element to close
          ParseError(Parser, L"Unexpected token `%s`", Token);
          Status = EFI_NOT_READY;
        }
        // Pop the top open tag from the stack
        Stack = XmlParser->Stack;
        XmlParser->Stack = Stack->Previous;
        EfiFreePool(Stack);
        break;
      }
      // Tag attribute value
      Stack = XmlParser->Stack;
      if ((Stack == NULL) || (Stack->Tree == NULL) || (Stack->Tree->Attributes == NULL)) {
        Status = EFI_NOT_READY;
        break;
      }
      // Find the current attribute
      List = Stack->Tree->Attributes;
      while (List->Next != NULL) {
        List = List->Next;
      }
      // Check to make sure there's not somehow already a value
      if (List->Attribute.Value != NULL) {
        // Unexpected value for attribute?
        Status = EFI_NOT_FOUND;
      }
      // Set the attribute value
      List->Attribute.Value = StrDup(Token);
      break;

    case XML_LANG_STATE_TAG_CLOSE:
      // Close tag name
      Stack = XmlParser->Stack;
      // Check token is valid attribute name
      Value = Token;
      if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
        ParseError(Parser, L"Invalid name `%s`", Token);
        return EFI_NOT_FOUND;
      }
      // Determine the current top of the stack's tree's name
      Value = NULL;
      if ((Stack != NULL) && (Stack->Tree != NULL) && (Stack->Tree->Name != NULL)) {
        Value = Stack->Tree->Name;
      }
      // Check there is a valid tag name to close
      if (Value != NULL) {
        if (StrCmp(Value, Token) != 0) {
          // Error: expected a different tag closed first
          Status = ParseError(Parser, L"Expected </%s> before </%s>", Value, Token);
          return EFI_NOT_FOUND;
        }
      } else {
        // Error: no tag to close so unexpected token
        ParseError(Parser, L"No matching `<%s>` for `</%s>` to close", Token, Token);
        return EFI_NOT_READY;
      }
      // Free stack object
      XmlParser->Stack = Stack->Previous;
      EfiFreePool(Stack);
      break;

    case XML_LANG_STATE_ENTITY:
      // Entity name
      Value = Token;
      // Get the previous state identifier
      Status = GetPreviousParseState(Parser, &PreviousId);
      if (EFI_ERROR(Status)) {
        break;
      }
      // Set the parser state to the previous state to parse entity replacement
      Status = SetParseState(Parser, PreviousId);
      if (EFI_ERROR(Status)) {
        break;
      }
      // Check if numeral representation of character
      if (*Token == L'#') {
        UINT32 Character = 0;
        // Numeral representation of character
        ++Token;
        if ((*Token == L'x') || (*Token == L'X')) {
          // Hexadecimal representation of character
          ++Token;
          while (*Token != '\0') {
            if ((*Token >= L'0') && (*Token <= L'9')) {
              Character <<= 4;
              Character |= (UINT32)(*Token - L'0');
            } else if ((*Token >= 'a') || (*Token <= 'f')) {
              Character <<= 4;
              Character |= (UINT32)((*Token - L'a') + 10);
            } else if ((*Token >= 'A') || (*Token <= 'F')) {
              Character <<= 4;
              Character |= (UINT32)((*Token - L'A') + 10);
            } else {
              break;
            }
            ++Token;
          }
        } else {
          // Decimal representation of character
          while (*Token != '\0') {
            // Check if character is valid decimal digit
            if ((*Token >= L'0') && (*Token <= L'9')) {
              Character *= 10;
              Character += (UINT32)(*Token - L'0');
            } else {
              // Not a valid decimal digit so break and ignore the rest
              break;
            }
            ++Token;
          }
        }
        // Ignore the null terminator character and any invalid print character
        if ((Character != '\0') && IsUnicodePrintCharacter(Character)) {
          // Replace the character entity with the character
          CHAR16 Str[3] = { L'\0', L'\0', L'\0' };
          if (Character >= 0x10000) {
            Str[0] = (CHAR16)(EFI_BITFIELD(Character, 10, 19) + 0xD800);
            Str[1] = (CHAR16)(EFI_BITFIELD(Character, 0, 9) + 0xDC00);
          } else {
            Str[0] = (CHAR16)Character;
          }
          // Store the old parser options and disable whitespace trimming
          PreviousOptions = XmlParser->Options;
          XmlParser->Options |= XML_OPTION_DISABLE_WHITESPACE_TRIMMING;
          // Call this function again with the entity's replacement token
          Status = ParseMacro(Parser, EfiUtf16Encoding(), Str, StrSize(Str), 0, NULL, Context);
          // Restore the old parser optiona
          XmlParser->Options = PreviousOptions;
        }
      } else {
        // Check token is valid entity name
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid entity name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          Index = 0;
          // Check for any predefined entities
          while (Index < ARRAY_COUNT(mXmlPredefinedEntities)) {
            // Check entity name is predefined
            if ((mXmlPredefinedEntities[Index].Name != NULL) &&
                (StriCmp(Token, mXmlPredefinedEntities[Index].Name) == 0)) {
              // Check there is a replacement value otherwise just skip this entity
              if ((mXmlPredefinedEntities[Index].Value != NULL) && (*(mXmlPredefinedEntities[Index].Value) != L'\0')) {
                // Store the old parser options and disable whitespace trimming
                PreviousOptions = XmlParser->Options;
                XmlParser->Options |= XML_OPTION_DISABLE_WHITESPACE_TRIMMING;
                // Call this function again with the entity's replacement token
                Status = ParseMacro(Parser, EfiUtf16Encoding(), mXmlPredefinedEntities[Index].Value, StrSize(mXmlPredefinedEntities[Index].Value), 0, mXmlPredefinedEntities[Index].Name, Context);
                // Restore the old parser optiona
                XmlParser->Options = PreviousOptions;
              }
              // Matched a predefined entity
              break;
            }
            ++Index;
          }
          // Check for any schema defined entities
          if (Index >= ARRAY_COUNT(mXmlPredefinedEntities)) {
            // Replace entity from schema
            XML_ENTITY *Entity = XmlParser->Document->Schema->Entities;
            while (Entity != NULL) {
              if (StrCmp(Entity->Name, Token) == 0) {
                // Check there is a replacement value otherwise just skip this entity
                if ((Entity->Replacement != NULL) && (*(Entity->Replacement) != L'\0')) {
                  // Store the old parser options and disable whitespace trimming
                  PreviousOptions = XmlParser->Options;
                  XmlParser->Options |= XML_OPTION_DISABLE_WHITESPACE_TRIMMING;
                  // Call this function again with the entity's replacement token
                  Status = ParseMacro(Parser, EfiUtf16Encoding(), Entity->Replacement, StrSize(Entity->Replacement), 0, Entity->Name, Context);
                  // Restore the old parser optiona
                  XmlParser->Options = PreviousOptions;
                }
                // Matched a schema entity
                break;
              }
              Entity = Entity->Next;
            }
            // Check if the entity was replaced
            if (Entity == NULL) {
              Status = EFI_NOT_FOUND;
            }
          }
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_NAME:
      // Schema name
      if ((XmlParser->Document != NULL) &&
          (XmlParser->Document->Schema != NULL) &&
          (XmlParser->Document->Schema->Name != NULL)) {
        // Check if the schema name if the same
        if (StriCmp(XmlParser->Document->Schema->Name, Token) != 0) {
          // The schema name already exists but is not the same name
          Status = EFI_NOT_READY;
        }
      } else {
        // Check token is valid document type name
        Value = Token;
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid document type name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          // Add the document if necessary
          Status = XmlDocumentCreate(&(XmlParser->Document), Token);
          // Add the schema if needed
          if (!EFI_ERROR(Status)) {
            Status = XmlSchemaCreate(&(XmlParser->Document->Schema), Token);
          }
        }
      }
      // Set the next state
      if (!EFI_ERROR(Status)) {
        Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_TYPE);
      }
      break;

    case XML_LANG_STATE_DOCUMENT_TYPE:
      // Schema type
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Document->Schema->Name == NULL)) {
        // The schema does not exist
        Status = EFI_NOT_READY;
      } else if (StriCmp(Token, L"[") == 0) {
        // Internal schema type
        XmlParser->Document->Schema->Type = XML_SCHEMA_TYPE_INTERNAL;
      } else if (StriCmp(Token, L"PUBLIC") == 0) {
        // Public schema type
        XmlParser->Document->Schema->Type = XML_SCHEMA_TYPE_PUBLIC;
      } else if (StriCmp(Token, L"SYSTEM") == 0) {
        // System schema type
        XmlParser->Document->Schema->Type = XML_SCHEMA_TYPE_SYSTEM;
      } else {
        // Unexpected schema type
        Status = EFI_NOT_FOUND;
      }
      break;

    case XML_LANG_STATE_DOCUMENT_PUBLIC_IDENTIFIER:
      // Schema public identifier
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Document->Schema->Name == NULL) ||
          (XmlParser->Document->Schema->Type != XML_SCHEMA_TYPE_PUBLIC)) {
        // Invalid schema
        Status = EFI_NOT_READY;
      } else if (XmlParser->Document->Schema->Identifier != NULL) {
        // The identifier already exists
        if (StriCmp(XmlParser->Document->Schema->Identifier, Token) != 0) {
          // The identifier already exists and is not the same
          Status = EFI_NOT_FOUND;
        }
      } else {
        // TODO: Check schema public location is valid public identifier
        // Set the schema public identifier
        XmlParser->Document->Schema->Identifier = StrDup(Token);
        if (XmlParser->Document->Schema->Identifier == NULL) {
          Status = EFI_OUT_OF_RESOURCES;
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_PUBLIC_LOCATION:
      // Schema location
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Document->Schema->Name == NULL) ||
          (XmlParser->Document->Schema->Identifier == NULL) ||
          (XmlParser->Document->Schema->Type != XML_SCHEMA_TYPE_PUBLIC)) {
        // Invalid schema
        Status = EFI_NOT_READY;
      } else if (XmlParser->Document->Schema->Location != NULL) {
        // The location already exists
        if (StriCmp(XmlParser->Document->Schema->Location, Token) != 0) {
          // The location already exists and is not the same
          Status = EFI_NOT_FOUND;
        }
      } else {
        // TODO: Check schema location is valid URI
        // Set the schema location
        XmlParser->Document->Schema->Location = StrDup(Token);
        if (XmlParser->Document->Schema->Location == NULL) {
          Status = EFI_OUT_OF_RESOURCES;
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_SYSTEM_LOCATION:
      // Schema location
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Document->Schema->Name == NULL) ||
          (XmlParser->Document->Schema->Type != XML_SCHEMA_TYPE_SYSTEM)) {
        // Invalid schema
        Status = EFI_NOT_READY;
      } else if (XmlParser->Document->Schema->Location != NULL) {
        // The location already exists
        if (StriCmp(XmlParser->Document->Schema->Location, Token) != 0) {
          // The location already exists and is not the same
          Status = EFI_NOT_FOUND;
        }
      } else {
        // TODO: Check schema location is valid local URI
        // Set the schema location
        XmlParser->Document->Schema->Location = StrDup(Token);
        if (XmlParser->Document->Schema->Location == NULL) {
          Status = EFI_OUT_OF_RESOURCES;
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ENTITY:
    case XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER:
      // Schema entity
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL)) {
        // There is no valid schema to store the entity
        Status = EFI_NOT_READY;
      } else {
        // Check token is valid entity name
        Value = Token;
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid entity name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          XML_ENTITY *Entity = NULL;
          // Check the entity does not already exist
          Entity = XmlParser->Document->Schema->Entities;
          while (Entity != NULL) {
            if (StrCmp(Entity->Name, Token) == 0) {
              // This is the entity
              break;
            }
            Entity = Entity->Next;
          }
          // Check if the entity already exists
          if (Entity == NULL) {
            // Create the new entity
            if (XmlParser->Document->Schema->Entities == NULL) {
              // Add the first entity
              XmlParser->Document->Schema->Entities = Entity = EfiAllocateByType(XML_ENTITY);
            } else {
              // Add the entity to the end of the entities
              Entity = XmlParser->Document->Schema->Entities;
              while (Entity->Next != NULL) {
                Entity = Entity->Next;
              }
              Entity = Entity->Next = EfiAllocateByType(XML_ENTITY);
            }
            if (Entity == NULL) {
              return EFI_OUT_OF_RESOURCES;
            }
            // Set entity name
            Entity->Name = StrDup(Token);
            Entity->Type = (StateId == XML_LANG_STATE_DOCUMENT_ENTITY_PARAMETER) ? XML_ENTITY_TYPE_PARAMETER : XML_ENTITY_TYPE_GENERAL;
          }
          // Set the current entity
          XmlParser->Entity = Entity;
          // Change the state to parse the value
          Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ENTITY_VALUE);
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ENTITY_VALUE:
      // Schema entity value
      if ((XmlParser->Entity == NULL) ||
          (XmlParser->Entity->Replacement != NULL)) {
        Status = EFI_NOT_READY;
      } else {
        XmlParser->Entity->Replacement = StrDup(Token);
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ENTITY_PUBLIC:
      // TODO: Schema entity public identifier
      
      break;

    case XML_LANG_STATE_DOCUMENT_ENTITY_SYSTEM:
      // TODO: Schema entity system identifier
      
      break;

    case XML_LANG_STATE_DOCUMENT_ELEMENT:
      // Schema element
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL)) {
        Status = EFI_NOT_READY;
      } else {
        Value = Token;
        // Check token is valid element name
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid element name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          // Check whether the element already exists
          XML_ELEMENT *Element = XmlParser->Document->Schema->Elements;
          while (Element != NULL) {
            if (StrCmp(Element->Name, Token) == 0) {
              break;
            }
            Element = Element->Next;
          }
          if (Element != NULL) {
            ParseError(Parser, L"Element already declared with name `%s`", Token);
            Status = EFI_NOT_READY;
          } else {
            // Create a new schema element
            if (XmlParser->Document->Schema->Elements == NULL) {
              XmlParser->Document->Schema->Elements = Element = EfiAllocateByType(XML_ELEMENT);
            } else {
              Element = XmlParser->Document->Schema->Elements;
              while (Element->Next != NULL) {
                Element = Element->Next;
              }
              Element = Element->Next = EfiAllocateByType(XML_ELEMENT);
            }
            if (Element == NULL) {
              return EFI_OUT_OF_RESOURCES;
            }
            // Set the schema element name
            Element->Name = StrDup(Token);
            // Set the current schema element
            XmlParser->Element = Element;
            // Set the next parser state
            Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN);
          }
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ELEMENT_ALIAS:
      // TODO: Schema element aliases

      break;

    case XML_LANG_STATE_DOCUMENT_ELEMENT_OPEN:
      // Schema element open tag omittance
      if (StriCmp(Token, L"-") == 0) {
        // TODO: Open tag must be present
      } else if (StriCmp(Token, L"O") == 0) {
        // TODO: Open tag may be omitted
      } else if (StriCmp(Token, L"(") == 0) {
        // TODO: No tag omittance, only content grouping
      } else if (StriCmp(Token, L"ANY") == 0) {
        // TODO: No tag omittance, any content
      } else if (StriCmp(Token, L"EMPTY") == 0) {
        // TODO: No tag omittance, no content
      } else if (StriCmp(Token, L"#PCDATA") == 0) {
        // TODO: No tag omittance, parsed character data as content
      } else {
        // Unexpected token
        ParseError(Parser, L"Expected `-` or `O` for open and close tag omittance, or `(`, `ANY`, `EMPTY`, or `#PCDATA` for child content");
        Status = EFI_NOT_FOUND;
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ELEMENT_CLOSE:
      // Schema element close tag omittance
      if (StriCmp(Token, L"-") == 0) {
        // TODO: Close tag must be present
      } else if (StriCmp(Token, L"O") == 0) {
        // TODO: Close tag may be omitted
      } else {
        // Unexpected token
        ParseError(Parser, L"Expected `-` or `O` for close omittance after providing open omittance");
        Status = EFI_NOT_FOUND;
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ELEMENT_CONTENT:
      // Schema element content
      if (StriCmp(Token, L"(") == 0) {
        // TODO: Open new content grouping
      } else if (StriCmp(Token, L")") == 0) {
        // TODO: Close this grouping of content
      } else if (StriCmp(Token, L",") == 0) {
        // TODO: Content must be present in specified order
      } else if (StriCmp(Token, L"|") == 0) {
        // TODO: Only one content from the grouping may exist (mutually exclusive)
      } else if (StriCmp(Token, L"&") == 0) {
        // TODO: Content can be present in any order
      } else if (StriCmp(Token, L"?") == 0) {
        // TODO: Content is optional but may only appear once
      } else if (StriCmp(Token, L"*") == 0) {
        // TODO: Content is optional but may appear more than once
      } else if (StriCmp(Token, L"+") == 0) {
        // TODO: Content is not optional but may appear more than once
      } else if (StriCmp(Token, L"ANY") == 0) {
        // TODO: Any content
      } else if (StriCmp(Token, L"EMPTY") == 0) {
        // TODO: No content
      } else if (StriCmp(Token, L"#PCDATA") == 0) {
        // TODO: Parsed character data as content
      } else {
        Value = Token;
        // Check token is valid element name
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid content element name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          // TODO: Group content
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ATTLIST:
      // Schema attribute list
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL)) {
        Status = EFI_NOT_READY;
      } else {
        Value = Token;
        // Check token is valid element name
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid element name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          // Check whether the element already exists
          XML_ELEMENT *Element = XmlParser->Document->Schema->Elements;
          while (Element != NULL) {
            if (StrCmp(Element->Name, Token) == 0) {
              break;
            }
            Element = Element->Next;
          }
          if (Element == NULL) {
            ParseError(Parser, L"No element declared with name `%s`", Token);
            Status = EFI_NOT_READY;
          } else {
            // Set the current schema element
            XmlParser->Element = Element;
            // Set the next parser state
            Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_NAME);
          }
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ATTLIST_NAME:
      // Scheme attribute list attribute name
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Element == NULL)) {
        Status = EFI_NOT_READY;
      } else {
        Value = Token;
        // Check token is valid attribute name
        if (EFI_ERROR(XmlIsValidName(&Value)) || (Value != NULL)) {
          ParseError(Parser, L"Invalid attribute name `%s`", Token);
          Status = EFI_NOT_FOUND;
        } else {
          // Check if attribute exists
          XML_ELEMENT_ATTRIBUTE *Attribute = XmlParser->Element->Attributes;
          while (Attribute != NULL) {
            if (StrCmp(Attribute->Name, Token) == 0) {
              break;
            }
            Attribute = Attribute->Next;
          }
          if (Attribute != NULL) {
            ParseError(Parser, L"Element `%s` already has attribute declared with name `%s`", XmlParser->Element->Name, Token);
            Status = EFI_NOT_READY;
          } else {
            // Create a new schema attribute
            if (XmlParser->Element->Attributes == NULL) {
              Attribute = EfiAllocateByType(XML_ELEMENT_ATTRIBUTE);
              XmlParser->Element->Attributes = Attribute;
            } else {
              Attribute = XmlParser->Element->Attributes;
              while (Attribute->Next != NULL) {
                Attribute = Attribute->Next;
              }
              Attribute->Next = EfiAllocateByType(XML_ELEMENT_ATTRIBUTE);
              Attribute = Attribute->Next;
            }
            if (Attribute == NULL) {
              return EFI_OUT_OF_RESOURCES;
            }
            // Set the schema attribute name
            Attribute->Name = StrDup(Token);
            // Set the current schema attribute
            XmlParser->Attribute = Attribute;
            // Set the next parser state
            Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_TYPE);
          }
        }
      }
      break;
      
    case XML_LANG_STATE_DOCUMENT_ATTLIST_TYPE:
      // Schema attribute list attribute type
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Element == NULL) ||
          (XmlParser->Attribute == NULL)) {
        Status = EFI_NOT_READY;
      } else if (StriCmp(Token, L"(") == 0) {
        // TODO: Enumeration
        Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION);
      } else if (StriCmp(Token, L"NOTATION") == 0) {
        // TODO: Notation attribute
        Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION);
      } else {
        if (StriCmp(Token, L"ID") == 0) {
          // TODO: Id attribute
        } else if (StriCmp(Token, L"CDATA") == 0) {
          // TODO: Character data attribute
        } else if (StriCmp(Token, L"IDREF") == 0) {
          // TODO: Idref attribute
        } else if (StriCmp(Token, L"IDREFS") == 0) {
          // TODO: Idrefs attribute
        } else if (StriCmp(Token, L"ENTITY") == 0) {
          // TODO: Entity attribute
        } else if (StriCmp(Token, L"NMTOKEN") == 0) {
          // TODO: Nametoken attribute
        } else if (StriCmp(Token, L"ENTITIES") == 0) {
          // TODO: Entities attribute
        } else if (StriCmp(Token, L"NMTOKENS") == 0) {
          // TODO: Nametokens attribute
        } else {
          // Unexpected token
          Status = EFI_NOT_FOUND;
          break;
        }
        // Set next parse state
        Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE);
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ATTLIST_ENUMERATION:
      // TODO: Schema attribute list attribute enumeration
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Element == NULL) ||
          (XmlParser->Attribute == NULL)) {
        Status = EFI_NOT_READY;
      } else if (StrCmp(Token, L")") == 0) {
        // TODO: Close the enumeration
        Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE);
      } else if (StrCmp(Token, L"|") == 0) {
        // TODO: Enumeration separator
      } else {
        // TODO: Enumeration value
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ATTLIST_PRESENCE:
      // Schema attribute list attribute presence
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Element == NULL) ||
          (XmlParser->Attribute == NULL)) {
        Status = EFI_NOT_READY;
      } else {
        if (StriCmp(Token, L"#FIXED") == 0) {
          // TODO: Fixed attribute value
          Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_DEFAULT);
        } else {
          if (StriCmp(Token, L"#IMPLIED") == 0) {
            // TODO: Implied attribute value
          } else if (StriCmp(Token, L"#REQUIRED") == 0) {
            // TODO: Required attribute value
          } else {
            // TODO: Set attribute default value
          }
          // Set next parse state
          Status = SetParseState(Parser, XML_LANG_STATE_DOCUMENT_ATTLIST_NAME);
        }
      }
      break;

    case XML_LANG_STATE_DOCUMENT_ATTLIST_DEFAULT:
      // Schema attribute list attribute default value
      if ((XmlParser->Document == NULL) ||
          (XmlParser->Document->Schema == NULL) ||
          (XmlParser->Element == NULL) ||
          (XmlParser->Attribute == NULL)) {
        Status = EFI_NOT_READY;
      } else {
        // TODO: Set attribute default value
        
        // Set next parse state
        Status = SetParseState(Parser, XML_LANG_STATE_TAG_END);
      }
      break;

    default:
      // Unexpected token or some unbelievable crazy thing happened and will never be able to be reproduced again
      Status = EFI_NOT_READY;
      break;
  }
  return Status;
}
// XmlCreate
/// Create an XML parser
/// @param Parser         On output, the XML parser, which must be freed by XmlFree
/// @param Source         The source being parsed
/// @return Whether the XML parser was created or not
/// @retval EFI_INVALID_PARAMETER If Parser is NULL or *Parser is not NULL
/// @retval EFI_OUT_OF_RESOURCES  If memory could not be allocated for the XML parser
/// @retval EFI_SUCCESS           If the XML parser was created successfully
EFI_STATUS
EFIAPI
XmlCreate (
  OUT XML_PARSER   **Parser,
  IN  CONST CHAR16  *Source OPTIONAL
) {
  EFI_STATUS  Status;
  XML_PARSER *Ptr;
  // Check parameters
  if ((Parser == NULL) || (*Parser != NULL)) {
    return EFI_INVALID_PARAMETER;
  }
  // Allocate XML  parser
  Ptr = EfiAllocateByType(XML_PARSER);
  if (Ptr == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }
  Ptr->Document = NULL;
  Ptr->Encoding = NULL;
  Ptr->Parser = NULL;
  Ptr->Stack = NULL;
  // Allocate language parser
  Status = CreateParserFromStates(&(Ptr->Parser), Source, XmlCallback, XML_LANG_STATE_SIGNATURE, ARRAY_COUNT(mXmlStates), mXmlStates);
  if (EFI_ERROR(Status)) {
    XmlFree(Ptr);
    return Status;
  }
  // Return XML parser
  *Parser = Ptr;
  return EFI_SUCCESS;
}
